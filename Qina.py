# -*- coding: utf-8 -*-
"""Qina.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fiDL0OOzxevY5Y3yNszUU746CTE-493o
"""

import os

os.system("pip install boto3")

os.system("pip install s3fs")

import pandas as pd
import s3fs

fs = s3fs.S3FileSystem(anon=True)
print(fs.ls("ookla-open-data/"))

print(fs.ls("ookla-open-data/parquet/"))

print(fs.ls("ookla-open-data/parquet/performance/"))

print(fs.ls("ookla-open-data/parquet/performance/type=mobile/"))

print(fs.ls('ookla-open-data/parquet/performance/type=mobile/year=2025'))

print(fs.ls('ookla-open-data/parquet/performance/type=mobile/year=2025/quarter=2'))

fs = s3fs.S3FileSystem(anon=True)

file_path = "ookla-open-data/parquet/performance/type=mobile/year=2025/quarter=2/2025-04-01_performance_mobile_tiles.parquet"

df = pd.read_parquet(file_path, filesystem=fs)

print(df.head())
print(df.columns)

# ÙÙŠ Colab: Ù†ØµØ¨ Ø§Ù„Ø­Ø²Ù… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© (Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚)
os.system("pip install s3fs geopandas rtree pyproj shapely --quiet")

import s3fs, pandas as pd, math
import geopandas as gpd
from shapely.geometry import Point

print(fs.ls('ookla-open-data/shapefiles'))

print(fs.ls('ookla-open-data/shapefiles/performance'))

print(fs.ls('ookla-open-data/shapefiles/performance/type=mobile'))

print(fs.ls('ookla-open-data/shapefiles/performance/type=mobile/year=2025'))

print(fs.ls('ookla-open-data/shapefiles/performance/type=mobile/year=2025/quarter=2'))



os.system("pip install fiona")

os.system("pip install --upgrade fiona geopandas pyogrio")

os.system("apt-get install -y gdal-bin")

os.system("ogr2ogr -f "ESRI Shapefile" /content/ne_110m_admin_0_countries.cpg/content/ne_110m_admin_0_countries.dbf/content/ne_110m_admin_0_countries.prj/content/ne_110m_admin_0_countries.shp/content/ne_110m_admin_0_countries.shx")

world = gpd.read_file("/content/ne_110m_admin_0_countries.shp")
egypt = world[world["NAME"].str.contains("Egypt", case=False)]
print(egypt)



# Define functions to convert quadkey to lat/lon
import math

def quadkey_to_tilexy(quadkey):
    """Converts a quadkey string to tile x, y coordinates and zoom level."""
    x, y = 0, 0
    level = len(quadkey)
    for i in range(level, 0, -1):
        mask = 1 << (i - 1)
        digit = int(quadkey[level - i])
        if digit == 0:
            pass
        elif digit == 1:
            x |= mask
        elif digit == 2:
            y |= mask
        elif digit == 3:
            x |= mask
            y |= mask
    return x, y, level

def tilexy_to_latlon(x, y, level):
    """Converts tile x, y coordinates and zoom level to latitude and longitude."""
    n = 2 ** level
    lon_deg = x / n * 360.0 - 180.0
    lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * y / n)))
    lat_deg = math.degrees(lat_rad)
    return lat_deg, lon_deg

# ØªØ­ÙˆÙŠÙ„ quadkey Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
df = df[df["quadkey"].notnull()].copy()
coords = df["quadkey"].apply(lambda q: tilexy_to_latlon(*quadkey_to_tilexy(q)))
df["lat"] = coords.apply(lambda t: t[0])
df["lon"] = coords.apply(lambda t: t[1])

# ØªØ­ÙˆÙŠÙ„ df Ù„ GeoDataFrame
gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.lon, df.lat), crs="EPSG:4326")

# Ù‚Ø±Ø§Ø¡Ø© Ø­Ø¯ÙˆØ¯ Ù…ØµØ±
world = gpd.read_file("/content/ne_110m_admin_0_countries.shp")
egypt = world[world["NAME"].str.contains("Egypt", case=False)]

# spatial join Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ù„Ø§Ø·Ø§Øª Ø¯Ø§Ø®Ù„ Ù…ØµØ±
gdf_egypt = gpd.sjoin(gdf, egypt, how="inner", predicate="within")

import folium
from folium.plugins import HeatMap

# ØªØ­Ø¯ÙŠØ¯ Ù…Ø±ÙƒØ² Ø§Ù„Ø®Ø±ÙŠØ·Ø© (Ù…Ø«Ù„Ø§Ù‹ ØªÙ‚Ø±ÙŠØ¨Ù‹Ø§ Ù…Ø±ÙƒØ² Ù…ØµØ±)
map_center = [26.0, 30.0]

# Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Folium
m = folium.Map(location=map_center, zoom_start=5)

# ØªØ¬Ù‡ÙŠØ² Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø±Ø§Ø±Ø© (latitude, longitude, intensity)
heat_data = [[row['lat'], row['lon'], row['avg_d_kbps']] for index, row in gdf_egypt.iterrows()]

# Ø¥Ø¶Ø§ÙØ© HeatMap
HeatMap(heat_data, radius=10, max_zoom=13).add_to(m)

# Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
m

# Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù GeoJSON Ù„Ù„Ù…Ø­Ø§ÙØ¸Ø§Øª
gdf_admin1 = gpd.read_file("/content/gadm41_EGY_1.json")

print(gdf_admin1["NAME_1"].unique())

Qina= gdf_admin1[gdf_admin1["NAME_1"] == "Qina"]

print(Qina)

print(df.columns)

os.system("pip install mercantile")

print(df["tile"].head())
print(df["tile_x"].head())
print(df["tile_y"].head())

import mercantile
from shapely.geometry import Point
import geopandas as gpd

# ØªØ­ÙˆÙŠÙ„ Ù…Ù† tile_x, tile_y, tile Ù„ lon/lat
points = []
for x, y, z in zip(df["tile_x"], df["tile_y"], df["tile"]):
    bounds = mercantile.bounds(x, y, z)  # Ø­Ø¯ÙˆØ¯ Ø§Ù„ØªØ§ÙŠÙ„
    lon = (bounds.west + bounds.east) / 2  # Ù…ØªÙˆØ³Ø· Ø§Ù„ØºØ±Ø¨ ÙˆØ§Ù„Ø´Ø±Ù‚ = Ù…Ø±ÙƒØ²
    lat = (bounds.north + bounds.south) / 2  # Ù…ØªÙˆØ³Ø· Ø§Ù„Ø´Ù…Ø§Ù„ ÙˆØ§Ù„Ø¬Ù†ÙˆØ¨ = Ù…Ø±ÙƒØ²
    points.append(Point(lon, lat))

# ØªØ­ÙˆÙŠÙ„ Ù„ GeoDataFrame
gdf_speed = gpd.GeoDataFrame(df, geometry=points, crs="EPSG:4326")

# ÙÙ„ØªØ±Ø© Ù‚Ù†Ø§
gdf_qena_speed = gpd.sjoin(gdf_speed, Qina, how="inner", predicate="within")

print("Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¯Ø§Ø®Ù„ Ù‚Ù†Ø§:", len(gdf_qena_speed))
gdf_qena_speed.head()

import geopandas as gpd
from shapely.geometry import Point

# 1ï¸âƒ£ ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø±Ø¹Ø§Øª Ù„Ù†Ù‚Ø§Ø· (GeoDataFrame) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… tile_x Ùˆ tile_y
geometry = [Point(xy) for xy in zip(df["tile_x"], df["tile_y"])]
gdf_speed = gpd.GeoDataFrame(df, geometry=geometry, crs="EPSG:4326")

# Optionally, rename columns for clarity if needed in subsequent steps
gdf_speed = gdf_speed.rename(columns={"tile_x": "lon", "tile_y": "lat"})


# 2ï¸âƒ£ ÙÙ„ØªØ±Ø© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù„ÙŠ Ø¬ÙˆÙ‡ Ù‚Ù†Ø§
# Make sure the 'Qina' GeoDataFrame is defined (run the cell that defines Qina first)
gdf_qena_speed = gpd.sjoin(gdf_speed, Qina, how="inner", predicate="within")

print("Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¯Ø§Ø®Ù„ Ù‚Ù†Ø§:", len(gdf_qena_speed))
gdf_qena_speed.head()

# Save gdf_qena_speed to a GeoJSON file
gdf_qena_speed.to_file("gdf_qena_speed.geojson", driver="GeoJSON")

import geopandas as gpd
from shapely.geometry import Point

# ØªØ­ÙˆÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø±Ø¹Ø§Øª Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
geometry = [Point(xy) for xy in zip(df["tile_x"], df["tile_y"])]
gdf_speed = gpd.GeoDataFrame(df, geometry=geometry, crs="EPSG:4326")

# ÙÙ„ØªØ±Ø© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù„ÙŠ Ø¬ÙˆÙ‡ Ù‚Ù†Ø§
gdf_qena_speed = gpd.sjoin(gdf_speed, Qina, how="inner", predicate="within")

print("Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¯Ø§Ø®Ù„ Ù‚Ù†Ø§:", len(gdf_qena_speed))
gdf_qena_speed.head()

import folium
from folium.plugins import HeatMap
import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon
import numpy as np
import rasterio
from rasterio.mask import mask

# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)


        try:
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")


print("Ø¹Ø¯Ø¯ Ø®Ù„Ø§ÙŠØ§ Ù‚Ù†Ø§:", len(gdf_qena_speed))
print("Ø¹Ø¯Ø¯ Ø®Ù„Ø§ÙŠØ§ ÙÙŠÙ‡Ø§ Ø³Ø±Ø¹Ø§Øª:", len(speed_hexes))
print("Ø¹Ø¯Ø¯ Ø®Ù„Ø§ÙŠØ§ dead zones:", len(dead_hexes))

os.system("pip install h3")

os.system("pip install rasterio")

import folium
from folium.plugins import HeatMap
import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon
import numpy as np
import rasterio
from rasterio.mask import mask


# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)


        try:
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")




# Ù…Ø±ÙƒØ² Ù‚Ù†Ø§
map_center = [26.2, 32.7]
m = folium.Map(location=map_center, zoom_start=8)

# 1ï¸âƒ£ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø­Ø§ÙØ¸Ù‡ (Ø­Ø¯ÙˆØ¯ Ù‚Ù†Ø§)
folium.GeoJson(Qina.geometry).add_to(m)

# 2ï¸âƒ£ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù„ÙˆÙ†Ø© Ø­Ø³Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø©
def color(speed):
    if speed < 2000:  # Ø£Ù‚Ù„ Ù…Ù† 2 Mbps
        return "red"
    elif speed < 8000:  # Ø¨ÙŠÙ† 2 Ùˆ 8 Mbps
        return "orange"
    else:
        return "green"

for _, row in gdf_qena_speed.iterrows():
    folium.CircleMarker(
        location=[row.geometry.y, row.geometry.x],
        radius=4,
        color=color(row["avg_d_kbps"]),
        fill=True,
        fill_opacity=0.7
    ).add_to(m)

# 3ï¸âƒ£ Ø¥Ø¶Ø§ÙØ© HeatMap Ø¹Ù„Ø´Ø§Ù† Ù†Ø´ÙˆÙ Ø§Ù„ØªÙˆØ²ÙŠØ¹
heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
HeatMap(heat_data, radius=15).add_to(m)

# 4ï¸âƒ£ Ø§Ù„Ù€ Dead Zones (Ø¹Ø±Ø¶ Ø§Ù„Ù€ dead zones Ø¨Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ)
# Use the gdf_dead_zones created in the previous step
folium.GeoJson(
    gdf_dead_zones.geometry,
    style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
).add_to(m)



# Ù†Ù‚Ø±Ø£ Ù…Ù„Ù Ø§Ù„Ø³ÙƒØ§Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯
pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
raster = rasterio.open(pop_path)
array = raster.read(1)
array[array <= 0] = np.nan

from rasterio.mask import mask

with rasterio.open(pop_path) as src:
    out_image, out_transform = mask(src, Qina.geometry, crop=True)
    array = out_image[0]

array[array <= 0] = np.nan


# Ù†Ø¬ÙŠØ¨ Ø§Ù„Ø£Ù…Ø§ÙƒÙ† Ø§Ù„Ù„ÙŠ ÙÙŠÙ‡Ø§ ØªÙƒØ¯Ø³ Ø³ÙƒØ§Ù†ÙŠ Ø¹Ø§Ù„ÙŠ
rows, cols = np.where(array > 500)  # Ø£ÙƒØªØ± Ù…Ù† 500 Ø´Ø®Øµ/ÙƒÙ…Â²
coords = [raster.xy(r, c) for r, c in zip(rows, cols)]

# Ù†Ø¶ÙŠÙ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
for lon, lat in coords[::200]:  # Ù†Ø®ÙÙ Ø§Ù„Ù†Ù‚Ø§Ø· Ø´ÙˆÙŠ
    folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
m

print(len(gdf_dead_zones))

kpis = {
    "dead_zones": len(dead_hexes),
    "complaints": (gdf_qena_speed["avg_d_kbps"] < 2000).sum(),
    "high_demand": np.count_nonzero(array > 500),

}

print(kpis)

os.system("pip install streamlit streamlit-folium folium pyngrok")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import folium
# from streamlit_folium import folium_static
# 
# # Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
# st.title("ğŸŒ Foresentra")
# 
# import streamlit as st
# import numpy as np
# from streamlit_folium import st_folium
# 
# st.set_page_config(page_title="Qina Dashboard", layout="wide")
# 
# # ----- Ø§Ù„Ø¹Ù†ÙˆØ§Ù† -----
# st.markdown("<h1 style='text-align:center; color:#2c3e50;'>ğŸ“Š Qina Internet Coverage Dashboard</h1>", unsafe_allow_html=True)
# st.write("")
# 
# # ----- Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª -----
# dead_zones = 0
# complaints = int(np.int64(27))
# high_demand = 304
# 
# # ----- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥ÙŠØ±Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠØ© -----
# # Ù†ÙØªØ±Ø¶ Ù…Ø«Ù„Ø§Ù‹ Ø£Ù† ÙƒÙ„ Ù…Ù†Ø·Ù‚Ø© High Demand Ù…Ù…ÙƒÙ† ØªØ­Ù‚Ù‚ 7,500 Ø¬Ù†ÙŠÙ‡ Ø´Ù‡Ø±ÙŠÙ‹Ø§
# revenue_per_area = 7500
# total_revenue = high_demand * revenue_per_area
# 
# # ----- ØªØµÙ…ÙŠÙ… Ø§Ù„ÙƒØ±ÙˆØª -----
# col1, col2, col3, col4 = st.columns(4)
# 
# with col1:
#     st.markdown(
#         f"""
#         <div style='background-color:#ffe6e6; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#c0392b;'>ğŸ•³ï¸ Dead Zones</h3>
#             <h1 style='color:#c0392b;'>{dead_zones}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col2:
#     st.markdown(
#         f"""
#         <div style='background-color:#e8f4fd; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#2980b9;'>ğŸ“¢ Complaints</h3>
#             <h1 style='color:#2980b9;'>{complaints}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col3:
#     st.markdown(
#         f"""
#         <div style='background-color:#eafbea; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#27ae60;'>ğŸ“ˆ High Demand</h3>
#             <h1 style='color:#27ae60;'>{high_demand}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col4:
#     st.markdown(
#         f"""
#         <div style='background-color:#fff9e6; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#f39c12;'>ğŸ’° Total Revenue</h3>
#             <h1 style='color:#f39c12;'>{total_revenue:,.0f} EGP</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# # ----- ÙØ§ØµÙ„ -----
# st.write("")
# st.markdown("---")
# st.write("")
# 
# #ÙƒÙˆØ¯ Ø§Ù„Ø®Ø±ÙŠØ·Ù‡
# 
# import folium
# from folium.plugins import HeatMap
# import h3
# import geopandas as gpd
# from shapely.geometry import Polygon, MultiPolygon
# import numpy as np
# import rasterio
# from rasterio.mask import mask
# 
# gdf_admin1 = gpd.read_file("/content/gadm41_EGY_1.json")
# 
# # Function to get H3 hexes within a polygon or multipolygon
# def get_hexes_in_geometry(geometry, res):
#     all_hexes = set()
#     if geometry.geom_type == 'Polygon':
#         polygons = [geometry]
#     elif geometry.geom_type == 'MultiPolygon':
#         polygons = geometry.geoms
#     else:
#         return all_hexes # Handle other geometry types if necessary
# 
#     for poly in polygons:
#         geojson = poly.__geo_interface__
#         h3_poly = []
#         # Exterior ring
#         outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
#         h3_poly.append(outer_loop)
#         # Inner rings (holes)
#         inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
#         h3_poly.extend(inner_loops)
# 
# 
#         try:
#             grid = h3.polygon_to_cells(h3_poly, res=res)
#             all_hexes.update(grid)
#         except ValueError as e:
#             print(f"  Error generating hexes for this polygon: {e}")
#             print(f"  Problematic h3_poly structure: {h3_poly}")
# 
# 
#     return all_hexes
# 
# # Get H3 hexes for Qina at resolution 7
# Qina= gdf_admin1[gdf_admin1["NAME_1"] == "Qina"]
# all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame
# 
# # Get H3 hexes for the points with speed data
# speed_hexes = set()
# for _, row in gdf_qena_speed.iterrows():
#     hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
#     speed_hexes.add(hex_id)
# 
# # Calculate dead zones (hexes in Qina without speed data)
# dead_hexes = all_qina_hexes - speed_hexes
# 
# # Convert dead zones to GeoDataFrame
# dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
# gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")
# 
# 
# 
# 
# # Ù…Ø±ÙƒØ² Ù‚Ù†Ø§
# map_center = [26.2, 32.7]
# m = folium.Map(location=map_center, zoom_start=8)
# 
# # 1ï¸âƒ£ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø­Ø§ÙØ¸Ù‡ (Ø­Ø¯ÙˆØ¯ Ù‚Ù†Ø§)
# folium.GeoJson(Qina.geometry).add_to(m)
# 
# # 2ï¸âƒ£ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù„ÙˆÙ†Ø© Ø­Ø³Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø©
# def color(speed):
#     if speed < 2000:  # Ø£Ù‚Ù„ Ù…Ù† 2 Mbps
#         return "red"
#     elif speed < 8000:  # Ø¨ÙŠÙ† 2 Ùˆ 8 Mbps
#         return "orange"
#     else:
#         return "green"
# 
# for _, row in gdf_qena_speed.iterrows():
#     folium.CircleMarker(
#         location=[row.geometry.y, row.geometry.x],
#         radius=4,
#         color=color(row["avg_d_kbps"]),
#         fill=True,
#         fill_opacity=0.7
#     ).add_to(m)
# 
# # 3ï¸âƒ£ Ø¥Ø¶Ø§ÙØ© HeatMap Ø¹Ù„Ø´Ø§Ù† Ù†Ø´ÙˆÙ Ø§Ù„ØªÙˆØ²ÙŠØ¹
# heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
# HeatMap(heat_data, radius=15).add_to(m)
# 
# # 4ï¸âƒ£ Ø§Ù„Ù€ Dead Zones (Ø¹Ø±Ø¶ Ø§Ù„Ù€ dead zones Ø¨Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ)
# # Use the gdf_dead_zones created in the previous step
# folium.GeoJson(
#     gdf_dead_zones.geometry,
#     style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
# ).add_to(m)
# 
# 
# 
# # Ù†Ù‚Ø±Ø£ Ù…Ù„Ù Ø§Ù„Ø³ÙƒØ§Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯
# pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
# raster = rasterio.open(pop_path)
# array = raster.read(1)
# array[array <= 0] = np.nan
# 
# from rasterio.mask import mask
# 
# with rasterio.open(pop_path) as src:
#     out_image, out_transform = mask(src, Qina.geometry, crop=True)
#     array = out_image[0]
# 
# array[array <= 0] = np.nan
# 
# 
# # Ù†Ø¬ÙŠØ¨ Ø§Ù„Ø£Ù…Ø§ÙƒÙ† Ø§Ù„Ù„ÙŠ ÙÙŠÙ‡Ø§ ØªÙƒØ¯Ø³ Ø³ÙƒØ§Ù†ÙŠ Ø¹Ø§Ù„ÙŠ
# rows, cols = np.where(array > 500)  # Ø£ÙƒØªØ± Ù…Ù† 500 Ø´Ø®Øµ/ÙƒÙ…Â²
# coords = [raster.xy(r, c) for r, c in zip(rows, cols)]
# 
# # Ù†Ø¶ÙŠÙ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
# for lon, lat in coords[::200]:  # Ù†Ø®ÙÙ Ø§Ù„Ù†Ù‚Ø§Ø· Ø´ÙˆÙŠ
#     folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
# m
# 
# 
# 
# # Ù…Ø«Ø§Ù„: Ù„Ùˆ Ø¹Ù†Ø¯Ùƒ Ù…Ø§Ø±ÙƒØ± Ø£Ùˆ Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ø¶ÙŠÙÙŠÙ‡Ø§ Ù‡Ù†Ø§
# # folium.Marker([26.2, 32.7], tooltip="Ù‚Ù†Ø§").add_to(m)
# 
# # Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
# folium_static(m)
#

import os

os.system("ngrok authtoken 33ptHpCNcjxpzgUriZemxYK2VUU_2XvVP1dH4xyLgNeP69stV")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import folium
# from streamlit_folium import folium_static
# import geopandas as gpd
# from shapely.geometry import Polygon, MultiPolygon
# import h3
# from folium.plugins import HeatMap
# import numpy as np
# import rasterio
# from rasterio.mask import mask
# 
# # ================================
# # 1ï¸âƒ£ ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ø©
# # ================================
# 
# # ÙƒÙ„ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø§Øª Ø§Ù„Ù…ØµØ±ÙŠØ© (GeoJSON Ø£Ùˆ SHP)
# gdf_admin1 = gpd.read_file("/content/gadm41_EGY_1.json")
# 
# # ÙÙ„ØªØ±Ø© Ù…Ø­Ø§ÙØ¸Ø© Ù‚Ù†Ø§
# Qina = gdf_admin1[gdf_admin1["NAME_1"] == "Qina"]
# 
# # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø±Ø¹Ø§Øª ÙÙŠ Ù‚Ù†Ø§ (GeoDataFrame)
# # Ù„Ùˆ Ø¹Ù†Ø¯Ùƒ Ù…Ù„Ù CSV Ø£Ùˆ GeoJSON Ø­Ø·ÙŠ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ØµØ­ÙŠØ­
# gdf_qena_speed = gpd.read_file("/content/ne_110m_admin_0_countries.shp")  # Ù…Ø«Ø§Ù„
# 
# # ================================
# # 2ï¸âƒ£ ØªØ¹Ø±ÙŠÙ Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
# # ================================
# 
# def get_hexes_in_geometry(geometry, res):
#     all_hexes = set()
#     polygons = []
#     if geometry.geom_type == 'Polygon':
#         polygons = [geometry]
#     elif geometry.geom_type == 'MultiPolygon':
#         polygons = geometry.geoms
# 
#     for poly in polygons:
#         try:
#             grid = h3.polygon_to_cells(poly.__geo_interface__, res=res)
#             all_hexes.update(grid)
#         except Exception as e:
#             print(f"Error generating hexes: {e}")
#     return all_hexes
# 
# def color(speed):
#     if speed < 2000:
#         return "red"
#     elif speed < 8000:
#         return "orange"
#     else:
#         return "green"
# 
# # ================================
# # 3ï¸âƒ£ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù€ Hexes Ùˆ Dead Zones
# # ================================
# 
# all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7)
# 
# speed_hexes = set()
# for _, row in gdf_qena_speed.iterrows():
#     hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
#     speed_hexes.add(hex_id)
# 
# dead_hexes = all_qina_hexes - speed_hexes
# 
# dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
# gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")
# 
# # ================================
# # 4ï¸âƒ£ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
# # ================================
# 
# st.title("ğŸŒ Foresentra")
# map_center = [26.2, 32.7]
# m = folium.Map(location=map_center, zoom_start=8)
# 
# # Ø­Ø¯ÙˆØ¯ Ù…Ø­Ø§ÙØ¸Ø© Ù‚Ù†Ø§
# folium.GeoJson(Qina.geometry).add_to(m)
# 
# # Ø§Ù„Ù†Ù‚Ø§Ø· Ø­Ø³Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø©
# for _, row in gdf_qena_speed.iterrows():
#     folium.CircleMarker(
#         location=[row.geometry.y, row.geometry.x],
#         radius=4,
#         color=color(row["avg_d_kbps"]),
#         fill=True,
#         fill_opacity=0.7
#     ).add_to(m)
# 
# # HeatMap
# heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
# HeatMap(heat_data, radius=15).add_to(m)
# 
# # Dead Zones Ø¨Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ
# folium.GeoJson(
#     gdf_dead_zones.geometry,
#     style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
# ).add_to(m)
# 
# # ================================
# # 5ï¸âƒ£ Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³ÙƒØ§Ù†
# # ================================
# 
# pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
# raster = rasterio.open(pop_path)
# array = raster.read(1)
# array[array <= 0] = np.nan
# 
# with rasterio.open(pop_path) as src:
#     out_image, out_transform = mask(src, Qina.geometry, crop=True)
#     array = out_image[0]
# array[array <= 0] = np.nan
# 
# rows, cols = np.where(array > 500)
# coords = [raster.xy(r, c) for r, c in zip(rows, cols)]
# 
# for lon, lat in coords[::200]:  # ØªØ®ÙÙŠÙ Ø§Ù„Ù†Ù‚Ø§Ø·
#     folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
# 
# # Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
# folium_static(m)
#



# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import folium
# from streamlit_folium import folium_static
# import geopandas as gpd
# from shapely.geometry import Polygon, MultiPolygon
# import h3
# from folium.plugins import HeatMap
# import numpy as np
# import rasterio
# from rasterio.mask import mask
# 
# # ================================
# # 1ï¸âƒ£ ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ø©
# # ================================
# 
# # ÙƒÙ„ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø§Øª Ø§Ù„Ù…ØµØ±ÙŠØ© (GeoJSON Ø£Ùˆ SHP)
# gdf_admin1 = gpd.read_file("/content/gadm41_EGY_1.json")
# 
# # ÙÙ„ØªØ±Ø© Ù…Ø­Ø§ÙØ¸Ø© Ù‚Ù†Ø§
# Qina = gdf_admin1[gdf_admin1["NAME_1"] == "Qina"]
# 
# # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø±Ø¹Ø§Øª ÙÙŠ Ù‚Ù†Ø§ (GeoDataFrame)
# # Load the GeoJSON file created in the notebook
# gdf_qena_speed = gpd.read_file("gdf_qena_speed.geojson")
# 
# # ================================
# # 2ï¸âƒ£ ØªØ¹Ø±ÙŠÙ Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
# # ================================
# 
# def get_hexes_in_geometry(geometry, res):
#     all_hexes = set()
#     polygons = []
#     if geometry.geom_type == 'Polygon':
#         polygons = [geometry]
#     elif geometry.geom_type == 'MultiPolygon':
#         polygons = geometry.geoms
# 
#     for poly in polygons:
#         try:
#             grid = h3.polygon_to_cells(poly.__geo_interface__, res=res)
#             all_hexes.update(grid)
#         except Exception as e:
#             print(f"Error generating hexes: {e}")
#     return all_hexes
# 
# def color(speed):
#     if speed < 2000:
#         return "red"
#     elif speed < 8000:
#         return "orange"
#     else:
#         return "green"
# 
# # ================================
# # 3ï¸âƒ£ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù€ Hexes Ùˆ Dead Zones
# # ================================
# 
# all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7)
# 
# speed_hexes = set()
# for _, row in gdf_qena_speed.iterrows():
#     geom = row.geometry
#     # Ù„Ùˆ Ø§Ù„Ù†Ù‚Ø·Ø© ÙØ¹Ù„Ø§Ù‹ Point Ù†Ø³ØªØ®Ø¯Ù…Ù‡Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©ØŒ ÙˆÙ„Ùˆ Polygon Ù†Ø¬ÙŠØ¨ Ù…Ø±ÙƒØ²Ù‡Ø§
#     if geom.geom_type == "Point":
#         lat, lon = geom.y, geom.x
#     else:
#         centroid = geom.centroid
#         lat, lon = centroid.y, centroid.x
# 
# speed_hexes = set()
# 
# for idx, row in gdf_qena_speed.iterrows():
#     geom = row.geometry
# 
#     # Ù„Ùˆ Ø§Ù„Ø´ÙƒÙ„ Ù…Ø¶Ù„Ø¹ Ø£Ùˆ Ø£ÙƒØ«Ø± Ù…Ù† Ù…Ø¶Ù„Ø¹ØŒ Ù†Ø­Ø³Ø¨ Ù…Ø±ÙƒØ²Ù‡
#     if geom.geom_type != "Point":
#         geom = geom.centroid
# 
#     # Ù†Ø­ÙˆÙ„ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù„Ø®Ù„ÙŠØ© H3
#     hex_id = h3.latlng_to_cell(geom.y, geom.x, 7)
# 
#     speed_hexes.add(hex_id)
# 
# # ÙˆØ¨Ø¹Ø¯ÙŠÙ† Ù†Ø³ØªØ®Ø¯Ù…Ù‡ Ù‡Ù†Ø§
# dead_hexes = all_qina_hexes - speed_hexes
# 
# 
# speed_hexes.add(hex_id)
# 
# 
# dead_hexes = all_qina_hexes - speed_hexes
# 
# dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
# gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")
# 
# # ================================
# # 4ï¸âƒ£ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
# # ================================
# 
# st.title("ğŸŒ Foresentra")
# 
# 
# import streamlit as st
# import numpy as np
# from streamlit_folium import st_folium
# 
# st.set_page_config(page_title="Qina Dashboard", layout="wide")
# 
# # ----- Ø§Ù„Ø¹Ù†ÙˆØ§Ù† -----
# st.markdown("<h1 style='text-align:center; color:#2c3e50;'>ğŸ“Š Qina Internet Coverage Dashboard</h1>", unsafe_allow_html=True)
# st.write("")
# 
# # ----- Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª -----
# dead_zones = 0
# complaints = int(np.int64(27))
# high_demand = 304
# 
# # ----- Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥ÙŠØ±Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠØ© -----
# # Ù†ÙØªØ±Ø¶ Ù…Ø«Ù„Ø§Ù‹ Ø£Ù† ÙƒÙ„ Ù…Ù†Ø·Ù‚Ø© High Demand Ù…Ù…ÙƒÙ† ØªØ­Ù‚Ù‚ 7,500 Ø¬Ù†ÙŠÙ‡ Ø´Ù‡Ø±ÙŠÙ‹Ø§
# revenue_per_area = 7500
# total_revenue = high_demand * revenue_per_area
# 
# # ----- ØªØµÙ…ÙŠÙ… Ø§Ù„ÙƒØ±ÙˆØª -----
# col1, col2, col3, col4 = st.columns(4)
# 
# with col1:
#     st.markdown(
#         f"""
#         <div style='background-color:#ffe6e6; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#c0392b;'>ğŸ•³ï¸ Dead Zones</h3>
#             <h1 style='color:#c0392b;'>{dead_zones}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col2:
#     st.markdown(
#         f"""
#         <div style='background-color:#e8f4fd; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#2980b9;'>ğŸ“¢ Complaints</h3>
#             <h1 style='color:#2980b9;'>{complaints}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col3:
#     st.markdown(
#         f"""
#         <div style='background-color:#eafbea; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#27ae60;'>ğŸ“ˆ High Demand</h3>
#             <h1 style='color:#27ae60;'>{high_demand}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col4:
#     st.markdown(
#         f"""
#         <div style='background-color:#fff9e6; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#f39c12;'>ğŸ’° Total Revenue</h3>
#             <h1 style='color:#f39c12;'>{total_revenue:,.0f} EGP</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# # ----- ÙØ§ØµÙ„ -----
# st.write("")
# st.markdown("---")
# st.write("")
# 
# # ----- Ø§Ù„Ø®Ø±ÙŠØ·Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ) -----
# # st_folium(map_qina, width=900, height=550)
# 
# 
# 
# 
# #-------------------------------------------
# map_center = [26.2, 32.7]
# m = folium.Map(location=map_center, zoom_start=8)
# 
# # Ø­Ø¯ÙˆØ¯ Ù…Ø­Ø§ÙØ¸Ø© Ù‚Ù†Ø§
# folium.GeoJson(Qina.geometry).add_to(m)
# 
# # Ø§Ù„Ù†Ù‚Ø§Ø· Ø­Ø³Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø©
# for _, row in gdf_qena_speed.iterrows():
#     folium.CircleMarker(
#         location=[row.geometry.centroid.y, row.geometry.centroid.x],
#         radius=4,
#         color=color(row["avg_d_kbps"]),
#         fill=True,
#         fill_opacity=0.7
#     ).add_to(m)
# 
# # HeatMap
# heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
# HeatMap(heat_data, radius=15).add_to(m)
# 
# # Dead Zones Ø¨Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ
# folium.GeoJson(
#     gdf_dead_zones.geometry,
#     style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
# ).add_to(m)
# 
# # ================================
# # 5ï¸âƒ£ Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³ÙƒØ§Ù†
# # ================================
# 
# pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
# raster = rasterio.open(pop_path)
# array = raster.read(1)
# array[array <= 0] = np.nan
# 
# with rasterio.open(pop_path) as src:
#     out_image, out_transform = mask(src, Qina.geometry, crop=True)
#     array = out_image[0]
# array[array <= 0] = np.nan
# 
# rows, cols = np.where(array > 500)
# coords = [rasterio.open(pop_path).xy(r, c) for r, c in zip(rows, cols)]
# 
# for lon, lat in coords[::200]:  # ØªØ®ÙÙŠÙ Ø§Ù„Ù†Ù‚Ø§Ø·
#     folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
# 
# # Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
# folium_static(m)



from pyngrok import ngrok

# Set the ngrok authtoken (replace with your actual authtoken)
os.system("ngrok authtoken 33ptHpCNcjxpzgUriZemxYK2VUU_2XvVP1dH4xyLgNeP69stV")

public_url = ngrok.connect(8501)
print("Ø§ÙØªØ­ÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ù† Ù‡Ù†Ø§:", public_url)

print(gdf_qena_speed.columns)



os.system("streamlit run app.py --server.port 8501")



import folium
from folium.plugins import HeatMap
import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon
import numpy as np
import rasterio
from rasterio.mask import mask


# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)


        try:
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")




# Ù…Ø±ÙƒØ² Ù‚Ù†Ø§
map_center = [26.2, 32.7]
m = folium.Map(location=map_center, zoom_start=8)

# 1ï¸âƒ£ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø­Ø§ÙØ¸Ù‡ (Ø­Ø¯ÙˆØ¯ Ù‚Ù†Ø§)
folium.GeoJson(Qina.geometry).add_to(m)

# 2ï¸âƒ£ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù„ÙˆÙ†Ø© Ø­Ø³Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø©
def color(speed):
    if speed < 2000:  # Ø£Ù‚Ù„ Ù…Ù† 2 Mbps
        return "red"
    elif speed < 8000:  # Ø¨ÙŠÙ† 2 Ùˆ 8 Mbps
        return "orange"
    else:
        return "green"

for _, row in gdf_qena_speed.iterrows():
    folium.CircleMarker(
        location=[row.geometry.y, row.geometry.x],
        radius=4,
        color=color(row["avg_d_kbps"]),
        fill=True,
        fill_opacity=0.7
    ).add_to(m)

# 3ï¸âƒ£ Ø¥Ø¶Ø§ÙØ© HeatMap Ø¹Ù„Ø´Ø§Ù† Ù†Ø´ÙˆÙ Ø§Ù„ØªÙˆØ²ÙŠØ¹
heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
HeatMap(heat_data, radius=15).add_to(m)

# 4ï¸âƒ£ Ø§Ù„Ù€ Dead Zones (Ø¹Ø±Ø¶ Ø§Ù„Ù€ dead zones Ø¨Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ)
# Use the gdf_dead_zones created in the previous step
folium.GeoJson(
    gdf_dead_zones.geometry,
    style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
).add_to(m)



# Ù†Ù‚Ø±Ø£ Ù…Ù„Ù Ø§Ù„Ø³ÙƒØ§Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯
pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
raster = rasterio.open(pop_path)
array = raster.read(1)
array[array <= 0] = np.nan

from rasterio.mask import mask

with rasterio.open(pop_path) as src:
    out_image, out_transform = mask(src, Qina.geometry, crop=True)
    array = out_image[0]

array[array <= 0] = np.nan


# Ù†Ø¬ÙŠØ¨ Ø§Ù„Ø£Ù…Ø§ÙƒÙ† Ø§Ù„Ù„ÙŠ ÙÙŠÙ‡Ø§ ØªÙƒØ¯Ø³ Ø³ÙƒØ§Ù†ÙŠ Ø¹Ø§Ù„ÙŠ
rows, cols = np.where(array > 500)  # Ø£ÙƒØªØ± Ù…Ù† 500 Ø´Ø®Øµ/ÙƒÙ…Â²
coords = [raster.xy(r, c) for r, c in zip(rows, cols)]

# Ù†Ø¶ÙŠÙ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
for lon, lat in coords[::200]:  # Ù†Ø®ÙÙ Ø§Ù„Ù†Ù‚Ø§Ø· Ø´ÙˆÙŠ
    folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
m



import folium
from folium.plugins import HeatMap
import h3
import geopandas as gpd
from shapely.geometry import Polygon
import numpy as np
import rasterio
from rasterio.mask import mask

# --------------------------
# ğŸ§© Ø¯Ø§Ù„Ø© ØªØ¬ÙŠØ¨ Ø®Ù„Ø§ÙŠØ§ H3 Ø¯Ø§Ø®Ù„ Ø­Ø¯ÙˆØ¯ Ù…Ø¹ÙŠÙ†Ø© (Polygon Ø£Ùˆ MultiPolygon)
# --------------------------
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry is None:
        return all_hexes

    # ÙÙŠ Ø­Ø§Ù„Ø© polygon Ø£Ùˆ multipolygon
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = list(geometry.geoms)
    else:
        return all_hexes

    for poly in polygons:
        geojson = poly.__geo_interface__
        try:
            # Ù†Ø¬Ù‡Ø² Ø§Ù„Ø´ÙƒÙ„ Ø¨ØµÙŠØºØ© lat, lon
            h3_poly = []
            outer = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
            h3_poly.append(outer)
            for inner_ring in geojson['coordinates'][1:]:
                h3_poly.append([(coord[1], coord[0]) for coord in inner_ring])

            # ØªÙˆÙ„ÙŠØ¯ Ø®Ù„Ø§ÙŠØ§ H3
            hexes = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(hexes)
        except Exception as e:
            print("Error in polygon:", e)
            continue

    return all_hexes

# --------------------------
# ğŸ—ºï¸ ØªÙˆÙ„ÙŠØ¯ Ø®Ù„Ø§ÙŠØ§ Ù‚Ù†Ø§ ÙˆØ§Ù„Ù€ Dead Zones
# --------------------------
res = 6 # Ø¯Ù‚Ø© H3
Qina_poly = Qina.geometry.iloc[0]  # Ø­Ø¯ÙˆØ¯ Ù‚Ù†Ø§
all_qina_hexes = get_hexes_in_geometry(Qina_poly, res)

# Ø®Ù„Ø§ÙŠØ§ ÙÙŠÙ‡Ø§ Ø¨ÙŠØ§Ù†Ø§Øª Ø³Ø±Ø¹Ø©
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, res)
    speed_hexes.add(hex_id)

# Ø®Ù„Ø§ÙŠØ§ Ù…Ø§ÙÙŠÙ‡Ø§Ø´ Ø¨ÙŠØ§Ù†Ø§Øª (dead zones)
dead_hexes = all_qina_hexes - speed_hexes
print("Ø¹Ø¯Ø¯ Ø®Ù„Ø§ÙŠØ§ dead zones:", len(dead_hexes))

# ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù€ dead zones Ø¥Ù„Ù‰ Ù…Ø¶Ù„Ø¹Ø§Øª
dead_zone_polygons = []
for hex_id in dead_hexes:
    boundary = h3.cell_to_boundary(hex_id)
    poly = Polygon([(lng, lat) for lat, lng in boundary])
    dead_zone_polygons.append(poly)

# Ø¥Ù†Ø´Ø§Ø¡ GeoDataFrame
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")
print("Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆÙ„ÙŠØ¬ÙˆÙ†Ø§Øª ÙÙŠ gdf_dead_zones:", len(gdf_dead_zones))

# --------------------------
# ğŸ—ºï¸ Ø±Ø³Ù… Ø§Ù„Ø®Ø±ÙŠØ·Ø©
# --------------------------
map_center = [26.2, 32.7]
m = folium.Map(location=map_center, zoom_start=8)

# 1ï¸âƒ£ Ø­Ø¯ÙˆØ¯ Ù‚Ù†Ø§
folium.GeoJson(Qina.geometry, name="Qina boundary").add_to(m)

# 2ï¸âƒ£ Dead Zones Ø¨Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ
if len(gdf_dead_zones) > 0:
    folium.GeoJson(
        gdf_dead_zones,
        style_function=lambda x: {
            'fillColor': 'gray',
            'color': 'gray',
            'weight': 0.5,
            'fillOpacity': 0.7
        },
        name="Dead Zones"
    ).add_to(m)

# 3ï¸âƒ£ Ø§Ù„Ù†Ù‚Ø§Ø· Ø­Ø³Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø©
def color(speed):
    if speed < 2000:
        return "red"
    elif speed < 8000:
        return "orange"
    else:
        return "green"

for _, row in gdf_qena_speed.iterrows():
    folium.CircleMarker(
        location=[row.geometry.y, row.geometry.x],
        radius=4,
        color=color(row["avg_d_kbps"]),
        fill=True,
        fill_opacity=0.7
    ).add_to(m)

# 4ï¸âƒ£ HeatMap
heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
HeatMap(heat_data, radius=15).add_to(m)

# --------------------------
# ğŸ‘¥ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø³ÙƒØ§Ù†
# --------------------------
pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"

with rasterio.open(pop_path) as src:
    out_image, out_transform = mask(src, Qina.geometry, crop=True)
    array = out_image[0]

array[array <= 0] = np.nan

rows, cols = np.where(array > 500)
coords = [rasterio.open(pop_path).xy(r, c) for r, c in zip(rows, cols)]

for lon, lat in coords[::200]:
    folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)

m

print("Ø¹Ø¯Ø¯ Ø®Ù„Ø§ÙŠØ§ Ù‚Ù†Ø§:", len(all_qina_hexes))

print("Ø¹Ø¯Ø¯ Ø®Ù„Ø§ÙŠØ§ ÙÙŠÙ‡Ø§ Ø³Ø±Ø¹Ø§Øª:", len(speed_hexes))

print("Ø¹Ø¯Ø¯ Ø®Ù„Ø§ÙŠØ§ dead zones:", len(dead_hexes))

os.system("pip install rasterio")

import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon

# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)

        # Debugging print statements
        print("Processing polygon:")
        print(f"  Geometry type: {poly.geom_type}")
        print(f"  H3 polygon input format (first few points): {h3_poly[0][:5]}") # Print first 5 points of outer loop

        try:
            # Use h3.polygon_to_cells instead of h3.polygon_to_cells_geojson
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
            print(f"  Successfully generated {len(grid)} hexes for this polygon.")
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    # Use h3.latlng_to_cell instead of h3.geo_to_h3
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")

print("\nNumber of dead zone hexes:", len(dead_hexes))
print("\nGeoDataFrame of dead zones created:")
display(gdf_dead_zones.head())

np.nanmax(array)

import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon

# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)

        # Debugging print statements
        print("Processing polygon:")
        print(f"  Geometry type: {poly.geom_type}")
        print(f"  H3 polygon input format (first few points): {h3_poly[0][:5]}") # Print first 5 points of outer loop

        try:
            # Use h3.polygon_to_cells instead of h3.polygon_to_cells_geojson
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
            print(f"  Successfully generated {len(grid)} hexes for this polygon.")
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    # Use h3.latlng_to_cell instead of h3.geo_to_h3
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")

print("\nNumber of dead zone hexes:", len(dead_hexes))
print("\nGeoDataFrame of dead zones created:")
display(gdf_dead_zones.head())

# Ù‚Ø±Ø§Ø¡Ø© Ø­Ø¯ÙˆØ¯ Ù…ØµØ± (assuming egypt_boundaries is already loaded)
# If egypt_boundaries is not loaded, add the code to load it here.
# import geopandas as gpd
# boundaries_path = "/content/gadm41_EGY_1.json"
# egypt_boundaries = gpd.read_file(boundaries_path)

# Ø§Ø®ØªÙŠØ§Ø± Ø­Ø¯ÙˆØ¯ Ù…Ø­Ø§ÙØ¸Ø© Ù‚Ù†Ø§ Ù…Ù† GeoDataFrame
# ØªØ£ÙƒØ¯ÙŠ Ù…Ù† Ø£Ù† Ø§Ø³Ù… Ø¹Ù…ÙˆØ¯ Ø§Ø³Ù… Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø© Ù‡Ùˆ 'NAME_1' ÙˆØ£Ù† Ø§Ø³Ù… Ù‚Ù†Ø§ Ù…ÙƒØªÙˆØ¨ Ø¨Ù†ÙØ³ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
Qina = egypt_boundaries[egypt_boundaries['NAME_1'] == 'Qina']

print("ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø­Ø¯ÙˆØ¯ Ù‚Ù†Ø§:")
display(Qina)

import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon

# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)

        # Debugging print statements
        print("Processing polygon:")
        print(f"  Geometry type: {poly.geom_type}")
        print(f"  H3 polygon input format (first few points): {h3_poly[0][:5]}") # Print first 5 points of outer loop

        try:
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
            print(f"  Successfully generated {len(grid)} hexes for this polygon.")
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")

print("\nNumber of dead zone hexes:", len(dead_hexes))
print("\nGeoDataFrame of dead zones created:")
display(gdf_dead_zones.head())

# ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ ÙˆØªØ¬Ù…ÙŠØ¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³ÙƒØ§Ù† Ù„Ù…Ø±Ø§ÙƒØ² Ù‚Ù†Ø§
population_data = []

for i, table in enumerate(tables):
    print(f"\n--- ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø±Ù‚Ù… {i+1} ---")
    # Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø°Ø§Øª Ø§Ù„ØµÙ„Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø±Ø¤ÙˆØ³ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶Ø© Ø³Ø§Ø¨Ù‚Ù‹Ø§
    # Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ù‡Ø°Ù‡ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø¥Ù„Ù‰ ØªØ¹Ø¯ÙŠÙ„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø±Ø£Ø³ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„ÙØ¹Ù„ÙŠ
    population_col = None
    type_col = None
    district_col = None

    # Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© ÙÙŠ Ø§Ù„Ø±Ø£Ø³
    for col in table.columns:
        if "Ø¹Ø¯Ø¯ Ø§Ù„Ø³ÙƒØ§Ù†" in str(col) or "Unnamed: 0" in str(col): # Consider Unnamed: 0 as potential population column
            population_col = col
        if "Ø§Ù„Ù†ÙˆØ¹" in str(col) or "Unnamed: 1" in str(col): # Consider Unnamed: 1 as potential type column
            type_col = col
        # Use broader keywords for district column
        if any(keyword in str(col) for keyword in ["Ø§Ù„Ù‚Ø³Ù…", "Ø§Ù„Ù…Ø±ÙƒØ²", "Ù…Ø±ÙƒØ²", "Ù…Ø¯ÙŠÙ†Ø©"]):
             district_col = col
        # If no specific district column is found, check Unnamed columns for potential district names
        if district_col is None:
            for col in table.columns:
                 if "Unnamed" in str(col) and col != population_col and col != type_col:
                      # Check if this Unnamed column contains potential district names
                      if table[col].astype(str).str.contains("Ù‚Ù†Ø§|Ø§Ù„ÙˆÙ‚Ù|ÙØ±Ø´ÙˆØ·|Ø£Ø¨Ùˆ Ø·Ø´Øª|Ø¯Ø´Ù†Ø§|Ø§Ù„ÙˆÙ‚Ù|Ù‚ÙØ·|Ù†Ù‚Ø§Ø¯Ø©|Ø§Ù„Ù‚Ø±Ù†Ø©|Ø£Ø±Ù…Ù†Øª|Ø§Ù„ÙˆÙ‚Ù|Ø¥Ø³Ù†Ø§|Ø§Ù„ÙˆØ§Ø­Ø§Øª Ø§Ù„Ø®Ø§Ø±Ø¬Ø©|Ø§Ù„Ø¯Ø§Ø®Ù„Ø©|Ø§Ù„ÙØ±Ø§ÙØ±Ø©|Ø¨Ø§Ø±ÙŠØ³|Ø¨Ù„Ø§Ø·|Ù…Ø¯ÙŠÙ†Ø© Ù‚Ù†Ø§ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©|Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©", na=False).any():
                           district_col = col
                           break # Found a potential district column


    if population_col is not None and (type_col is not None or district_col is not None):
        print(f"  ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø©: Ø§Ù„Ø³ÙƒØ§Ù† ('{population_col}'), Ø§Ù„Ù†ÙˆØ¹ ('{type_col}'), Ø§Ù„Ù‚Ø³Ù…/Ø§Ù„Ù…Ø±ÙƒØ² ('{district_col}')")
        # ØªØµÙÙŠØ© Ø§Ù„ØµÙÙˆÙ Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ "Ø¬Ù…Ù„Ø©" ÙÙŠ Ø¹Ù…ÙˆØ¯ Ø§Ù„Ù†ÙˆØ¹ (Ø¥Ø°Ø§ ÙˆØ¬Ø¯) Ø£Ùˆ Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ù…Ø±ÙƒØ² ÙÙŠ Ø¹Ù…ÙˆØ¯ Ø§Ù„Ù‚Ø³Ù…/Ø§Ù„Ù…Ø±ÙƒØ²
        if type_col is not None and type_col in table.columns:
             # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØµÙÙˆÙ Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒÙ„Ù…Ø© "Ø¬Ù…Ù„Ø©"
            total_rows = table[table[type_col].astype(str).str.contains("Ø¬Ù…Ù„Ø©", na=False)]
            print(f"  ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {len(total_rows)} ØµÙÙˆÙ 'Ø¬Ù…Ù„Ø©'.")
            # Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ø³Ù… Ø§Ù„Ù…Ø±ÙƒØ² ÙˆØ¹Ø¯Ø¯ Ø§Ù„Ø³ÙƒØ§Ù† Ù…Ù† ØµÙÙˆÙ "Ø¬Ù…Ù„Ø©"
            for index, row in total_rows.iterrows():
                  center_name = None
                  population_value = None

                  # Try to get center name from potential district column
                  if district_col is not None and district_col in row and pd.notna(row[district_col]):
                       center_name_candidate = str(row[district_col]).strip()
                       if any(keyword in center_name_candidate for keyword in ["Ù…Ø±ÙƒØ²", "Ù…Ø¯ÙŠÙ†Ø©", "Ù‚Ø³Ù…", "Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©", "Ø¬Ù…Ù„Ø©"]): # Include "Ø¬Ù…Ù„Ø©" as some tables have it in the district column
                            center_name = center_name_candidate

                  # If center name not found in district column, look in other columns in the same row
                  if not center_name:
                       for col in table.columns:
                            if col != population_col and col != type_col and pd.notna(row[col]):
                                 col_value = str(row[col]).strip()
                                 if any(keyword in col_value for keyword in ["Ù…Ø±ÙƒØ²", "Ù…Ø¯ÙŠÙ†Ø©", "Ù‚Ø³Ù…", "Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©", "Ø¬Ù…Ù„Ø©"]):
                                      center_name = col_value
                                      break # Stop at the first potential center name

                  # Extract population value from the identified population column
                  if population_col in row and pd.notna(row[population_col]):
                       try:
                            population_value = float(str(row[population_col]).replace(',', '').strip())
                       except ValueError:
                            population_value = None # Value is not numeric

                  # If a valid center name and population value are found, add them
                  if center_name and population_value is not None:
                       # Avoid adding "Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©" rows unless specifically needed later
                       if "Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©" not in center_name:
                           population_data.append({"Ø§Ù„Ù…Ø±ÙƒØ²": center_name.replace("Ø¬Ù…Ù„Ø©", "").strip(), "Ø¹Ø¯Ø¯ Ø§Ù„Ø³ÙƒØ§Ù† Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ": population_value}) # Clean up "Ø¬Ù…Ù„Ø©" from name
                           print(f"    Ø§Ø³ØªØ®Ù„Ø§Øµ: Ø§Ù„Ù…Ø±ÙƒØ² '{center_name.replace('Ø¬Ù…Ù„Ø©', '').strip()}', Ø§Ù„Ø³ÙƒØ§Ù† '{population_value}'")
                       else:
                           print(f"    ØªÙ… ØªØ®Ø·ÙŠ ØµÙ Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©: Ø§Ù„Ù…Ø±ÙƒØ² '{center_name}', Ø§Ù„Ø³ÙƒØ§Ù† '{population_value}'")

        elif district_col is not None and district_col in table.columns and population_col is not None and population_col in table.columns:
             # If no type column, try extracting directly based on district column containing keywords
             print("  Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¹Ù…ÙˆØ¯ Ù†ÙˆØ¹ØŒ Ù†Ø­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù‚Ø³Ù…/Ø§Ù„Ù…Ø±ÙƒØ² ÙˆØ§Ù„Ø³ÙƒØ§Ù†.")
             for index, row in table.iterrows():
                  center_name = None
                  population_value = None

                  if pd.notna(row[district_col]):
                       center_name_candidate = str(row[district_col]).strip()
                       if any(keyword in center_name_candidate for keyword in ["Ù…Ø±ÙƒØ²", "Ù…Ø¯ÙŠÙ†Ø©", "Ù‚Ø³Ù…", "Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©", "Ø¬Ù…Ù„Ø©"]):
                            center_name = center_name_candidate

                            if population_col in row and pd.notna(row[population_col]):
                                 try:
                                      population_value = float(str(row[population_col]).replace(',', '').strip())
                                 except ValueError:
                                      population_value = None

                            if center_name and population_value is not None and "Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©" not in center_name:
                                 population_data.append({"Ø§Ù„Ù…Ø±ÙƒØ²": center_name.replace("Ø¬Ù…Ù„Ø©", "").strip(), "Ø¹Ø¯Ø¯ Ø§Ù„Ø³ÙƒØ§Ù† Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ": population_value})
                                 print(f"    Ø§Ø³ØªØ®Ù„Ø§Øµ: Ø§Ù„Ù…Ø±ÙƒØ² '{center_name.replace('Ø¬Ù…Ù„Ø©', '').strip()}', Ø§Ù„Ø³ÙƒØ§Ù† '{population_value}'")
                            elif "Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©" in center_name:
                                print(f"    ØªÙ… ØªØ®Ø·ÙŠ ØµÙ Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©: Ø§Ù„Ù…Ø±ÙƒØ² '{center_name}', Ø§Ù„Ø³ÙƒØ§Ù† '{population_value}'")


    else:
        print("  Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© (Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø³ÙƒØ§Ù† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ ÙˆØ¹Ù…ÙˆØ¯ Ø§Ù„Ù†ÙˆØ¹ Ø£Ùˆ Ø§Ù„Ù‚Ø³Ù…/Ø§Ù„Ù…Ø±ÙƒØ²) ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø¯ÙˆÙ„.")


# ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹Ø© Ø¥Ù„Ù‰ DataFrame
population_df = pd.DataFrame(population_data)

# ØªÙ†Ø¸ÙŠÙ Ø¥Ø¶Ø§ÙÙŠ (Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØµÙÙˆÙ Ø§Ù„Ù…ÙƒØ±Ø±Ø©)
if not population_df.empty:
    population_df = population_df.drop_duplicates(subset=["Ø§Ù„Ù…Ø±ÙƒØ²"])
    # ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø²Ø§Ù„Ø© Ø£ÙŠ ØµÙÙˆÙ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø© Ø§Ù„ØªÙŠ Ù‚Ø¯ ØªÙƒÙˆÙ† ØªØ³Ù„Ù„Øª
    population_df = population_df[~population_df["Ø§Ù„Ù…Ø±ÙƒØ²"].astype(str).str.contains("Ø¥Ø¬Ù…Ø§Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©", na=False)]


print("\nØ¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³ÙƒØ§Ù† Ø§Ù„Ù…Ø¬Ù…Ø¹Ø© Ù„Ù…Ø±Ø§ÙƒØ² Ù‚Ù†Ø§:")
if not population_df.empty:
    display(population_df)
else:
    print("Ù„Ù… ÙŠØªÙ… ØªØ¬Ù…ÙŠØ¹ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø³ÙƒØ§Ù†ÙŠØ©.")


# Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©: Ø§Ù„Ø±Ø¨Ø· Ø¨Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠØ© Ù„Ù…Ø±Ø§ÙƒØ² Ù‚Ù†Ø§

# Ø¹Ø±Ø¶ Ø±Ø¤ÙˆØ³ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø®Ù…Ø³Ø© Ø§Ù„Ù…Ø³ØªØ®Ù„ØµØ©
print(f"ØªÙ… Ø§Ø³ØªØ®Ù„Ø§Øµ {len(tables)} Ø¬Ø¯ÙˆÙ„ Ù…Ù† Ø§Ù„ØµÙØ­Ø§Øª 90-94.")

for i, table in enumerate(tables):
    print(f"\n--- Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø±Ù‚Ù… {i+1} (Ù…Ù† Ø§Ù„ØµÙØ­Ø§Øª 90-94) ---")
    display(table.head())
    # ÙŠÙ…ÙƒÙ†ÙƒÙ Ø£ÙŠØ¶Ù‹Ø§ Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¥Ø°Ø§ ÙƒØ§Ù† ØµØºÙŠØ±Ù‹Ø§:
    # display(table)

# ÙÙ„ØªØ±Ø© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ù†Ø§
qena_table = None
keywords = ["Ù‚Ù†Ø§", "Qina", "Kena", "Quena"] # ÙƒÙ„Ù…Ø§Øª Ù…ÙØªØ§Ø­ÙŠØ© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ø¯ÙˆÙ„ Ù‚Ù†Ø§

for i, table in enumerate(tables):
    # ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ© Ù„Ù„Ø¨Ø­Ø« ÙÙŠÙ‡
    table_string = table.to_string()
    # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© ÙÙŠ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¬Ø¯ÙˆÙ„
    if any(keyword in table_string for keyword in keywords):
        print(f"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¬Ø¯ÙˆÙ„ ÙŠØ­ØªÙ…Ù„ Ø£Ù†Ù‡ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ù†Ø§ (Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø±Ù‚Ù… {i+1}).")
        qena_table = table
        # ÙŠÙ…ÙƒÙ†Ùƒ Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù‡Ù†Ø§ Ù„Ù„ØªØ£ÙƒØ¯
        # display(qena_table.head())
        # ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø§Ù„ØªÙˆÙ‚Ù Ø¹Ù†Ø¯ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙˆÙ„ Ø¬Ø¯ÙˆÙ„ Ù…Ø·Ø§Ø¨Ù‚ Ø£Ùˆ Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ø¯Ø§ÙˆÙ„ Ø£Ø®Ø±Ù‰ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        # break # Ø£Ø²Ù„ Ø¹Ù„Ø§Ù…Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ‚ Ù‡Ù†Ø§ Ù„Ù„ØªÙˆÙ‚Ù Ø¨Ø¹Ø¯ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙˆÙ„ Ø¬Ø¯ÙˆÙ„
    else:
      print(f"Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø±Ù‚Ù… {i+1} Ù„Ø§ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ©.")


if qena_table is not None:
    print("\nØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø¬Ø¯ÙˆÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ù†Ø§.")
    display(qena_table.head())
else:
    print("\nÙ„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¬Ø¯ÙˆÙ„ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ù†Ø§ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ©.")

# ÙÙŠ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©ØŒ Ø¥Ø°Ø§ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯ÙˆÙ„ØŒ Ø³Ù†Ù‚ÙˆÙ… Ø¨ØªÙ†Ø¸ÙŠÙ… Ø¨ÙŠØ§Ù†Ø§ØªÙ‡ ÙˆØ§Ø³ØªØ®Ù„Ø§Øµ Ø£Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø³ÙƒØ§Ù† Ù„ÙƒÙ„ Ù…Ø±ÙƒØ².

"""**Ù…Ù„Ø§Ø­Ø¸Ø© Ù‡Ø§Ù…Ø©:** Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù…Ù„ÙØ§Øª PDF Ù‚Ø¯ ÙŠÙƒÙˆÙ† ØµØ¹Ø¨Ù‹Ø§ ÙˆÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ù„Ù ÙˆØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ ÙÙŠÙ‡. Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø·ÙˆØ© Ø¥Ù„Ù‰ ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¨Ù†ÙŠØ© Ù…Ù„Ù Ø§Ù„Ù€ PDF Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ."""

os.system("pip install tabula-py --quiet")

import tabula

# ØªØ­Ø¯ÙŠØ¯ Ù…Ø³Ø§Ø± Ù…Ù„Ù Ø§Ù„Ù€ PDF Ø§Ù„Ø°ÙŠ Ù‚Ù…ØªÙ Ø¨ØªØ­Ù…ÙŠÙ„Ù‡
pdf_path = '/content/202331512347Ø¹Ø¯Ø¯ Ø§Ù„Ø³ÙƒØ§Ù† Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø±Ø§ÙƒØ² ÙˆØ§Ù„Ø§Ù‚Ø³Ø§Ù… ÙÙ‰ 1Ù€ 1Ù€ 2023.pdf'

# Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ù…Ù† Ù…Ù„Ù Ø§Ù„Ù€ PDF
# Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³ÙƒØ§Ù†
# ÙŠÙ…ÙƒÙ†ÙƒÙ Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙØ­Ø§Øª ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
try:
    # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØµÙØ­Ø§Øª Ù…Ù† 90 Ø¥Ù„Ù‰ 94
    tables = tabula.read_pdf(pdf_path, pages='90-94', multiple_tables=True)
    print(f"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {len(tables)} Ø¬Ø¯ÙˆÙ„ ÙÙŠ Ø§Ù„ØµÙØ­Ø§Øª 90-94 Ù…Ù† Ù…Ù„Ù PDF.")
    # Ø¹Ø±Ø¶ Ø£ÙˆÙ„ Ø¬Ø¯ÙˆÙ„ Ù„Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
    if tables:
        display(tables[0].head())
    else:
        print("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ Ø¬Ø¯Ø§ÙˆÙ„ ÙÙŠ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©.")

except Exception as e:
    print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù PDF: {e}")

# ÙÙŠ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©ØŒ Ø³Ù†Ù‚ÙˆÙ… Ø¨ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ù„ØµØ© ÙˆØªØ­Ø¯ÙŠØ¯ Ø¬Ø¯ÙˆÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ù†Ø§.

!wget https://hub.worldpop.org/geodata/10.5258/SOTON/WP00803/egy_ppp_2025.tif

import geopandas as gpd
import rasterio
from rasterio.mask import mask
import matplotlib.pyplot as plt

# 1) Ø§ÙØªØ­ÙŠ Ø­Ø¯ÙˆØ¯ Ù…ØµØ±
# gdf = gpd.read_file("gadm41_EGY_1.shp") # Already loaded as egypt_boundaries

# 2) Ø§Ø®ØªØ§Ø±ÙŠ Ù‚Ù†Ø§
# qena = gdf[gdf['NAME_1'] == 'Qena'] # Use egypt_boundaries and correct spelling
qena = egypt_boundaries[egypt_boundaries['NAME_1'] == 'Qina']


# 3) Ø§ÙØªØ­ÙŠ Ù…Ù„Ù Ø§Ù„Ø³ÙƒØ§Ù† (Ø§Ù„Ù„ÙŠ Ù†Ø²Ù„ØªÙŠÙ‡)
pop = rasterio.open("/content/egy_pop_2025_CN_100m_R2024B_v1.tif")  # ØºÙŠØ±ÙŠ Ø§Ù„Ø§Ø³Ù… Ù„Ùˆ Ø§Ù„Ù…Ù„Ù Ø¹Ù†Ø¯Ùƒ 2020 Ø£Ùˆ Ø³Ù†Ø© ØªØ§Ù†ÙŠØ©

# 4) Ù‚Øµ Ù…Ù„Ù Ø§Ù„Ø³ÙƒØ§Ù† Ø¹Ù„Ù‰ Ø­Ø¯ÙˆØ¯ Ù‚Ù†Ø§
out_image, out_transform = mask(pop, qena.geometry, crop=True)
population_array = out_image[0]

# 5) Ø´ÙˆÙÙŠ Ø§Ù„Ù†ØªÙŠØ¬Ø©
plt.imshow(population_array, cmap="viridis")
plt.colorbar(label="Population count")
plt.title("Population distribution in Qena")
plt.show()

# Ø§Ø®ØªÙŠØ§Ø± Ø­Ø¯ÙˆØ¯ Ù…Ø­Ø§ÙØ¸Ø© Ù‚Ù†Ø§ Ù…Ù† GeoDataFrame
# ØªØ£ÙƒØ¯ÙŠ Ù…Ù† Ø£Ù† Ø§Ø³Ù… Ø¹Ù…ÙˆØ¯ Ø§Ø³Ù… Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø© Ù‡Ùˆ 'NAME_1' ÙˆØ£Ù† Ø§Ø³Ù… Ù‚Ù†Ø§ Ù…ÙƒØªÙˆØ¨ Ø¨Ù†ÙØ³ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
qena_boundary = egypt_boundaries[egypt_boundaries['NAME_1'] == 'Qina']

print("ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø­Ø¯ÙˆØ¯ Ù‚Ù†Ø§:")
display(qena_boundary)

import geopandas as gpd

# ØªØ­Ø¯ÙŠØ¯ Ù…Ø³Ø§Ø± Ù…Ù„Ù Ø§Ù„Ø­Ø¯ÙˆØ¯
boundaries_path = "/content/gadm41_EGY_1.json"

try:
    # Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù Ø§Ù„Ø­Ø¯ÙˆØ¯
    egypt_boundaries = gpd.read_file(boundaries_path)

    print(f"ØªÙ… Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù: {boundaries_path}")
    print("\nØ£ÙˆÙ„ 5 ØµÙÙˆÙ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø¯ÙˆØ¯:")
    display(egypt_boundaries.head())

    print("\nØ£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø©:")
    print(egypt_boundaries.columns)

    # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¹Ø±Ø¶ Ù‚ÙŠÙ… ÙØ±ÙŠØ¯Ø© Ù…Ù† Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø¨Ù„Ø¯ (Ù‚Ø¯ ÙŠØ®ØªÙ„Ù Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙˆØ¯)
    if 'COUNTRY' in egypt_boundaries.columns:
        print("\nØ§Ù„Ù‚ÙŠÙ… Ø§Ù„ÙØ±ÙŠØ¯Ø© ÙÙŠ Ø¹Ù…ÙˆØ¯ 'COUNTRY':")
        print(egypt_boundaries['COUNTRY'].unique())
    elif 'NAME_0' in egypt_boundaries.columns:
        print("\nØ§Ù„Ù‚ÙŠÙ… Ø§Ù„ÙØ±ÙŠØ¯Ø© ÙÙŠ Ø¹Ù…ÙˆØ¯ 'NAME_0':")
        print(egypt_boundaries['NAME_0'].unique())
    else:
        print("\nÙ„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù…ÙˆØ¯ Ø¨Ø§Ø³Ù… 'COUNTRY' Ø£Ùˆ 'NAME_0'.")

    print(f"\nØ¹Ø¯Ø¯ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠØ© ÙÙŠ Ø§Ù„Ù…Ù„Ù: {len(egypt_boundaries)}")


except Exception as e:
    print(f"Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù Ø§Ù„Ø­Ø¯ÙˆØ¯: {e}")



import geopandas as gpd
import rasterio
from rasterio.mask import mask

# Ù…Ù„ÙØ§ØªÙƒ
pop_file = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"   # Ù…Ù„Ù Ø§Ù„Ø³ÙƒØ§Ù† Ø§Ù„Ù„ÙŠ Ù†Ø²Ù„ØªÙŠÙ‡
# admin_file = "/content/ne_110m_admin_0_countries.shp"  # Ù…Ù„Ù Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø§Øª - Ù„Ø§ Ù†Ø­ØªØ§Ø¬Ù‡ Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ø¢Ù†

# Ù†Ù‚Ø±Ø£ shapefile (already loaded as egypt_boundaries)
# gdf = gpd.read_file(admin_file)

# Ù†Ø®ØªØ§Ø± Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© (Ù‚Ù†Ø§) Ù…Ù† egypt_boundaries
governorate = egypt_boundaries[egypt_boundaries['NAME_1'] == 'Qina']

# Ù†ÙØªØ­ Ù…Ù„Ù Ø§Ù„Ø³ÙƒØ§Ù†
with rasterio.open(pop_file) as src:
    out_image, out_transform = mask(src, governorate.geometry, crop=True)
    out_meta = src.meta.copy()

# Ù†Ø­Ø¯Ø« Ø§Ù„Ù…ÙŠØªØ§Ø¯Ø§ØªØ§
out_meta.update({
    "driver": "GTiff",
    "height": out_image.shape[1],
    "width": out_image.shape[2],
    "transform": out_transform
})

# Ù†Ø­ÙØ¸ Ø§Ù„Ù†Ø§ØªØ¬ ÙÙŠ Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯
with rasterio.open("qina_population.tif", "w", **out_meta) as dest:
    dest.write(out_image)

print("ØªÙ… Ù‚Øµ Ù…Ù„Ù Ø§Ù„Ø³ÙƒØ§Ù† Ø¹Ù„Ù‰ Ø­Ø¯ÙˆØ¯ Ù‚Ù†Ø§ ÙˆØ­ÙØ¸Ù‡ ÙƒÙ€ qina_population.tif")