# -*- coding: utf-8 -*-
"""Qina.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fiDL0OOzxevY5Y3yNszUU746CTE-493o
"""

import os

os.system("pip install boto3")

os.system("pip install s3fs")

import pandas as pd
import s3fs

fs = s3fs.S3FileSystem(anon=True)
print(fs.ls("ookla-open-data/"))

print(fs.ls("ookla-open-data/parquet/"))

print(fs.ls("ookla-open-data/parquet/performance/"))

print(fs.ls("ookla-open-data/parquet/performance/type=mobile/"))

print(fs.ls('ookla-open-data/parquet/performance/type=mobile/year=2025'))

print(fs.ls('ookla-open-data/parquet/performance/type=mobile/year=2025/quarter=2'))

fs = s3fs.S3FileSystem(anon=True)

file_path = "ookla-open-data/parquet/performance/type=mobile/year=2025/quarter=2/2025-04-01_performance_mobile_tiles.parquet"

df = pd.read_parquet(file_path, filesystem=fs)

print(df.head())
print(df.columns)

# في Colab: نصب الحزم المطلوبة (قد يستغرق)
os.system("pip install s3fs geopandas rtree pyproj shapely --quiet")

import s3fs, pandas as pd, math
import geopandas as gpd
from shapely.geometry import Point

print(fs.ls('ookla-open-data/shapefiles'))

print(fs.ls('ookla-open-data/shapefiles/performance'))

print(fs.ls('ookla-open-data/shapefiles/performance/type=mobile'))

print(fs.ls('ookla-open-data/shapefiles/performance/type=mobile/year=2025'))

print(fs.ls('ookla-open-data/shapefiles/performance/type=mobile/year=2025/quarter=2'))



os.system("pip install fiona")

os.system("pip install --upgrade fiona geopandas pyogrio")

os.system("apt-get install -y gdal-bin")

os.system("ogr2ogr -f "ESRI Shapefile" /content/ne_110m_admin_0_countries.cpg/content/ne_110m_admin_0_countries.dbf/content/ne_110m_admin_0_countries.prj/content/ne_110m_admin_0_countries.shp/content/ne_110m_admin_0_countries.shx")

world = gpd.read_file("/content/ne_110m_admin_0_countries.shp")
egypt = world[world["NAME"].str.contains("Egypt", case=False)]
print(egypt)



# Define functions to convert quadkey to lat/lon
import math

def quadkey_to_tilexy(quadkey):
    """Converts a quadkey string to tile x, y coordinates and zoom level."""
    x, y = 0, 0
    level = len(quadkey)
    for i in range(level, 0, -1):
        mask = 1 << (i - 1)
        digit = int(quadkey[level - i])
        if digit == 0:
            pass
        elif digit == 1:
            x |= mask
        elif digit == 2:
            y |= mask
        elif digit == 3:
            x |= mask
            y |= mask
    return x, y, level

def tilexy_to_latlon(x, y, level):
    """Converts tile x, y coordinates and zoom level to latitude and longitude."""
    n = 2 ** level
    lon_deg = x / n * 360.0 - 180.0
    lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * y / n)))
    lat_deg = math.degrees(lat_rad)
    return lat_deg, lon_deg

# تحويل quadkey لإحداثيات
df = df[df["quadkey"].notnull()].copy()
coords = df["quadkey"].apply(lambda q: tilexy_to_latlon(*quadkey_to_tilexy(q)))
df["lat"] = coords.apply(lambda t: t[0])
df["lon"] = coords.apply(lambda t: t[1])

# تحويل df ل GeoDataFrame
gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.lon, df.lat), crs="EPSG:4326")

# قراءة حدود مصر
world = gpd.read_file("/content/ne_110m_admin_0_countries.shp")
egypt = world[world["NAME"].str.contains("Egypt", case=False)]

# spatial join للحصول على البلاطات داخل مصر
gdf_egypt = gpd.sjoin(gdf, egypt, how="inner", predicate="within")

import folium
from folium.plugins import HeatMap

# تحديد مركز الخريطة (مثلاً تقريبًا مركز مصر)
map_center = [26.0, 30.0]

# إنشاء خريطة Folium
m = folium.Map(location=map_center, zoom_start=5)

# تجهيز بيانات الحرارة (latitude, longitude, intensity)
heat_data = [[row['lat'], row['lon'], row['avg_d_kbps']] for index, row in gdf_egypt.iterrows()]

# إضافة HeatMap
HeatMap(heat_data, radius=10, max_zoom=13).add_to(m)

# عرض الخريطة
m

# قراءة ملف GeoJSON للمحافظات
gdf_admin1 = gpd.read_file("/content/gadm41_EGY_1.json")

print(gdf_admin1["NAME_1"].unique())

Qina= gdf_admin1[gdf_admin1["NAME_1"] == "Qina"]

print(Qina)

print(df.columns)

os.system("pip install mercantile")

print(df["tile"].head())
print(df["tile_x"].head())
print(df["tile_y"].head())

import mercantile
from shapely.geometry import Point
import geopandas as gpd

# تحويل من tile_x, tile_y, tile ل lon/lat
points = []
for x, y, z in zip(df["tile_x"], df["tile_y"], df["tile"]):
    bounds = mercantile.bounds(x, y, z)  # حدود التايل
    lon = (bounds.west + bounds.east) / 2  # متوسط الغرب والشرق = مركز
    lat = (bounds.north + bounds.south) / 2  # متوسط الشمال والجنوب = مركز
    points.append(Point(lon, lat))

# تحويل ل GeoDataFrame
gdf_speed = gpd.GeoDataFrame(df, geometry=points, crs="EPSG:4326")

# فلترة قنا
gdf_qena_speed = gpd.sjoin(gdf_speed, Qina, how="inner", predicate="within")

print("عدد النقاط داخل قنا:", len(gdf_qena_speed))
gdf_qena_speed.head()

import geopandas as gpd
from shapely.geometry import Point

# 1️⃣ تحويل بيانات السرعات لنقاط (GeoDataFrame) باستخدام tile_x و tile_y
geometry = [Point(xy) for xy in zip(df["tile_x"], df["tile_y"])]
gdf_speed = gpd.GeoDataFrame(df, geometry=geometry, crs="EPSG:4326")

# Optionally, rename columns for clarity if needed in subsequent steps
gdf_speed = gdf_speed.rename(columns={"tile_x": "lon", "tile_y": "lat"})


# 2️⃣ فلترة النقاط اللي جوه قنا
# Make sure the 'Qina' GeoDataFrame is defined (run the cell that defines Qina first)
gdf_qena_speed = gpd.sjoin(gdf_speed, Qina, how="inner", predicate="within")

print("عدد النقاط داخل قنا:", len(gdf_qena_speed))
gdf_qena_speed.head()

# Save gdf_qena_speed to a GeoJSON file
gdf_qena_speed.to_file("gdf_qena_speed.geojson", driver="GeoJSON")

import geopandas as gpd
from shapely.geometry import Point

# تحويل بيانات السرعات لإحداثيات
geometry = [Point(xy) for xy in zip(df["tile_x"], df["tile_y"])]
gdf_speed = gpd.GeoDataFrame(df, geometry=geometry, crs="EPSG:4326")

# فلترة النقاط اللي جوه قنا
gdf_qena_speed = gpd.sjoin(gdf_speed, Qina, how="inner", predicate="within")

print("عدد النقاط داخل قنا:", len(gdf_qena_speed))
gdf_qena_speed.head()

import folium
from folium.plugins import HeatMap
import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon
import numpy as np
import rasterio
from rasterio.mask import mask

# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)


        try:
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")


print("عدد خلايا قنا:", len(gdf_qena_speed))
print("عدد خلايا فيها سرعات:", len(speed_hexes))
print("عدد خلايا dead zones:", len(dead_hexes))

os.system("pip install h3")

os.system("pip install rasterio")

import folium
from folium.plugins import HeatMap
import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon
import numpy as np
import rasterio
from rasterio.mask import mask


# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)


        try:
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")




# مركز قنا
map_center = [26.2, 32.7]
m = folium.Map(location=map_center, zoom_start=8)

# 1️⃣ إضافة المحافظه (حدود قنا)
folium.GeoJson(Qina.geometry).add_to(m)

# 2️⃣ النقاط الملونة حسب السرعة
def color(speed):
    if speed < 2000:  # أقل من 2 Mbps
        return "red"
    elif speed < 8000:  # بين 2 و 8 Mbps
        return "orange"
    else:
        return "green"

for _, row in gdf_qena_speed.iterrows():
    folium.CircleMarker(
        location=[row.geometry.y, row.geometry.x],
        radius=4,
        color=color(row["avg_d_kbps"]),
        fill=True,
        fill_opacity=0.7
    ).add_to(m)

# 3️⃣ إضافة HeatMap علشان نشوف التوزيع
heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
HeatMap(heat_data, radius=15).add_to(m)

# 4️⃣ الـ Dead Zones (عرض الـ dead zones باللون الرمادي)
# Use the gdf_dead_zones created in the previous step
folium.GeoJson(
    gdf_dead_zones.geometry,
    style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
).add_to(m)



# نقرأ ملف السكان الجديد
pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
raster = rasterio.open(pop_path)
array = raster.read(1)
array[array <= 0] = np.nan

from rasterio.mask import mask

with rasterio.open(pop_path) as src:
    out_image, out_transform = mask(src, Qina.geometry, crop=True)
    array = out_image[0]

array[array <= 0] = np.nan


# نجيب الأماكن اللي فيها تكدس سكاني عالي
rows, cols = np.where(array > 500)  # أكتر من 500 شخص/كم²
coords = [raster.xy(r, c) for r, c in zip(rows, cols)]

# نضيف النقاط على الخريطة
for lon, lat in coords[::200]:  # نخفف النقاط شوي
    folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
m

print(len(gdf_dead_zones))

kpis = {
    "dead_zones": len(dead_hexes),
    "complaints": (gdf_qena_speed["avg_d_kbps"] < 2000).sum(),
    "high_demand": np.count_nonzero(array > 500),

}

print(kpis)

os.system("pip install streamlit streamlit-folium folium pyngrok")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import folium
# from streamlit_folium import folium_static
# 
# # العنوان
# st.title("🌍 Foresentra")
# 
# import streamlit as st
# import numpy as np
# from streamlit_folium import st_folium
# 
# st.set_page_config(page_title="Qina Dashboard", layout="wide")
# 
# # ----- العنوان -----
# st.markdown("<h1 style='text-align:center; color:#2c3e50;'>📊 Qina Internet Coverage Dashboard</h1>", unsafe_allow_html=True)
# st.write("")
# 
# # ----- البيانات -----
# dead_zones = 0
# complaints = int(np.int64(27))
# high_demand = 304
# 
# # ----- حساب الإيرادات التقريبية -----
# # نفترض مثلاً أن كل منطقة High Demand ممكن تحقق 7,500 جنيه شهريًا
# revenue_per_area = 7500
# total_revenue = high_demand * revenue_per_area
# 
# # ----- تصميم الكروت -----
# col1, col2, col3, col4 = st.columns(4)
# 
# with col1:
#     st.markdown(
#         f"""
#         <div style='background-color:#ffe6e6; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#c0392b;'>🕳️ Dead Zones</h3>
#             <h1 style='color:#c0392b;'>{dead_zones}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col2:
#     st.markdown(
#         f"""
#         <div style='background-color:#e8f4fd; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#2980b9;'>📢 Complaints</h3>
#             <h1 style='color:#2980b9;'>{complaints}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col3:
#     st.markdown(
#         f"""
#         <div style='background-color:#eafbea; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#27ae60;'>📈 High Demand</h3>
#             <h1 style='color:#27ae60;'>{high_demand}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col4:
#     st.markdown(
#         f"""
#         <div style='background-color:#fff9e6; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#f39c12;'>💰 Total Revenue</h3>
#             <h1 style='color:#f39c12;'>{total_revenue:,.0f} EGP</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# # ----- فاصل -----
# st.write("")
# st.markdown("---")
# st.write("")
# 
# #كود الخريطه
# 
# import folium
# from folium.plugins import HeatMap
# import h3
# import geopandas as gpd
# from shapely.geometry import Polygon, MultiPolygon
# import numpy as np
# import rasterio
# from rasterio.mask import mask
# 
# gdf_admin1 = gpd.read_file("/content/gadm41_EGY_1.json")
# 
# # Function to get H3 hexes within a polygon or multipolygon
# def get_hexes_in_geometry(geometry, res):
#     all_hexes = set()
#     if geometry.geom_type == 'Polygon':
#         polygons = [geometry]
#     elif geometry.geom_type == 'MultiPolygon':
#         polygons = geometry.geoms
#     else:
#         return all_hexes # Handle other geometry types if necessary
# 
#     for poly in polygons:
#         geojson = poly.__geo_interface__
#         h3_poly = []
#         # Exterior ring
#         outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
#         h3_poly.append(outer_loop)
#         # Inner rings (holes)
#         inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
#         h3_poly.extend(inner_loops)
# 
# 
#         try:
#             grid = h3.polygon_to_cells(h3_poly, res=res)
#             all_hexes.update(grid)
#         except ValueError as e:
#             print(f"  Error generating hexes for this polygon: {e}")
#             print(f"  Problematic h3_poly structure: {h3_poly}")
# 
# 
#     return all_hexes
# 
# # Get H3 hexes for Qina at resolution 7
# Qina= gdf_admin1[gdf_admin1["NAME_1"] == "Qina"]
# all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame
# 
# # Get H3 hexes for the points with speed data
# speed_hexes = set()
# for _, row in gdf_qena_speed.iterrows():
#     hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
#     speed_hexes.add(hex_id)
# 
# # Calculate dead zones (hexes in Qina without speed data)
# dead_hexes = all_qina_hexes - speed_hexes
# 
# # Convert dead zones to GeoDataFrame
# dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
# gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")
# 
# 
# 
# 
# # مركز قنا
# map_center = [26.2, 32.7]
# m = folium.Map(location=map_center, zoom_start=8)
# 
# # 1️⃣ إضافة المحافظه (حدود قنا)
# folium.GeoJson(Qina.geometry).add_to(m)
# 
# # 2️⃣ النقاط الملونة حسب السرعة
# def color(speed):
#     if speed < 2000:  # أقل من 2 Mbps
#         return "red"
#     elif speed < 8000:  # بين 2 و 8 Mbps
#         return "orange"
#     else:
#         return "green"
# 
# for _, row in gdf_qena_speed.iterrows():
#     folium.CircleMarker(
#         location=[row.geometry.y, row.geometry.x],
#         radius=4,
#         color=color(row["avg_d_kbps"]),
#         fill=True,
#         fill_opacity=0.7
#     ).add_to(m)
# 
# # 3️⃣ إضافة HeatMap علشان نشوف التوزيع
# heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
# HeatMap(heat_data, radius=15).add_to(m)
# 
# # 4️⃣ الـ Dead Zones (عرض الـ dead zones باللون الرمادي)
# # Use the gdf_dead_zones created in the previous step
# folium.GeoJson(
#     gdf_dead_zones.geometry,
#     style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
# ).add_to(m)
# 
# 
# 
# # نقرأ ملف السكان الجديد
# pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
# raster = rasterio.open(pop_path)
# array = raster.read(1)
# array[array <= 0] = np.nan
# 
# from rasterio.mask import mask
# 
# with rasterio.open(pop_path) as src:
#     out_image, out_transform = mask(src, Qina.geometry, crop=True)
#     array = out_image[0]
# 
# array[array <= 0] = np.nan
# 
# 
# # نجيب الأماكن اللي فيها تكدس سكاني عالي
# rows, cols = np.where(array > 500)  # أكتر من 500 شخص/كم²
# coords = [raster.xy(r, c) for r, c in zip(rows, cols)]
# 
# # نضيف النقاط على الخريطة
# for lon, lat in coords[::200]:  # نخفف النقاط شوي
#     folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
# m
# 
# 
# 
# # مثال: لو عندك ماركر أو بيانات أضيفيها هنا
# # folium.Marker([26.2, 32.7], tooltip="قنا").add_to(m)
# 
# # عرض الخريطة
# folium_static(m)
#

import os

os.system("ngrok authtoken 33ptHpCNcjxpzgUriZemxYK2VUU_2XvVP1dH4xyLgNeP69stV")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import folium
# from streamlit_folium import folium_static
# import geopandas as gpd
# from shapely.geometry import Polygon, MultiPolygon
# import h3
# from folium.plugins import HeatMap
# import numpy as np
# import rasterio
# from rasterio.mask import mask
# 
# # ================================
# # 1️⃣ تعريف البيانات المهمة
# # ================================
# 
# # كل المحافظات المصرية (GeoJSON أو SHP)
# gdf_admin1 = gpd.read_file("/content/gadm41_EGY_1.json")
# 
# # فلترة محافظة قنا
# Qina = gdf_admin1[gdf_admin1["NAME_1"] == "Qina"]
# 
# # بيانات السرعات في قنا (GeoDataFrame)
# # لو عندك ملف CSV أو GeoJSON حطي المسار الصحيح
# gdf_qena_speed = gpd.read_file("/content/ne_110m_admin_0_countries.shp")  # مثال
# 
# # ================================
# # 2️⃣ تعريف دوال المساعدة
# # ================================
# 
# def get_hexes_in_geometry(geometry, res):
#     all_hexes = set()
#     polygons = []
#     if geometry.geom_type == 'Polygon':
#         polygons = [geometry]
#     elif geometry.geom_type == 'MultiPolygon':
#         polygons = geometry.geoms
# 
#     for poly in polygons:
#         try:
#             grid = h3.polygon_to_cells(poly.__geo_interface__, res=res)
#             all_hexes.update(grid)
#         except Exception as e:
#             print(f"Error generating hexes: {e}")
#     return all_hexes
# 
# def color(speed):
#     if speed < 2000:
#         return "red"
#     elif speed < 8000:
#         return "orange"
#     else:
#         return "green"
# 
# # ================================
# # 3️⃣ إنشاء الـ Hexes و Dead Zones
# # ================================
# 
# all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7)
# 
# speed_hexes = set()
# for _, row in gdf_qena_speed.iterrows():
#     hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
#     speed_hexes.add(hex_id)
# 
# dead_hexes = all_qina_hexes - speed_hexes
# 
# dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
# gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")
# 
# # ================================
# # 4️⃣ إنشاء الخريطة
# # ================================
# 
# st.title("🌍 Foresentra")
# map_center = [26.2, 32.7]
# m = folium.Map(location=map_center, zoom_start=8)
# 
# # حدود محافظة قنا
# folium.GeoJson(Qina.geometry).add_to(m)
# 
# # النقاط حسب السرعة
# for _, row in gdf_qena_speed.iterrows():
#     folium.CircleMarker(
#         location=[row.geometry.y, row.geometry.x],
#         radius=4,
#         color=color(row["avg_d_kbps"]),
#         fill=True,
#         fill_opacity=0.7
#     ).add_to(m)
# 
# # HeatMap
# heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
# HeatMap(heat_data, radius=15).add_to(m)
# 
# # Dead Zones باللون الرمادي
# folium.GeoJson(
#     gdf_dead_zones.geometry,
#     style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
# ).add_to(m)
# 
# # ================================
# # 5️⃣ إضافة بيانات السكان
# # ================================
# 
# pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
# raster = rasterio.open(pop_path)
# array = raster.read(1)
# array[array <= 0] = np.nan
# 
# with rasterio.open(pop_path) as src:
#     out_image, out_transform = mask(src, Qina.geometry, crop=True)
#     array = out_image[0]
# array[array <= 0] = np.nan
# 
# rows, cols = np.where(array > 500)
# coords = [raster.xy(r, c) for r, c in zip(rows, cols)]
# 
# for lon, lat in coords[::200]:  # تخفيف النقاط
#     folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
# 
# # عرض الخريطة
# folium_static(m)
#



# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import folium
# from streamlit_folium import folium_static
# import geopandas as gpd
# from shapely.geometry import Polygon, MultiPolygon
# import h3
# from folium.plugins import HeatMap
# import numpy as np
# import rasterio
# from rasterio.mask import mask
# 
# # ================================
# # 1️⃣ تعريف البيانات المهمة
# # ================================
# 
# # كل المحافظات المصرية (GeoJSON أو SHP)
# gdf_admin1 = gpd.read_file("/content/gadm41_EGY_1.json")
# 
# # فلترة محافظة قنا
# Qina = gdf_admin1[gdf_admin1["NAME_1"] == "Qina"]
# 
# # بيانات السرعات في قنا (GeoDataFrame)
# # Load the GeoJSON file created in the notebook
# gdf_qena_speed = gpd.read_file("gdf_qena_speed.geojson")
# 
# # ================================
# # 2️⃣ تعريف دوال المساعدة
# # ================================
# 
# def get_hexes_in_geometry(geometry, res):
#     all_hexes = set()
#     polygons = []
#     if geometry.geom_type == 'Polygon':
#         polygons = [geometry]
#     elif geometry.geom_type == 'MultiPolygon':
#         polygons = geometry.geoms
# 
#     for poly in polygons:
#         try:
#             grid = h3.polygon_to_cells(poly.__geo_interface__, res=res)
#             all_hexes.update(grid)
#         except Exception as e:
#             print(f"Error generating hexes: {e}")
#     return all_hexes
# 
# def color(speed):
#     if speed < 2000:
#         return "red"
#     elif speed < 8000:
#         return "orange"
#     else:
#         return "green"
# 
# # ================================
# # 3️⃣ إنشاء الـ Hexes و Dead Zones
# # ================================
# 
# all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7)
# 
# speed_hexes = set()
# for _, row in gdf_qena_speed.iterrows():
#     geom = row.geometry
#     # لو النقطة فعلاً Point نستخدمها مباشرة، ولو Polygon نجيب مركزها
#     if geom.geom_type == "Point":
#         lat, lon = geom.y, geom.x
#     else:
#         centroid = geom.centroid
#         lat, lon = centroid.y, centroid.x
# 
# speed_hexes = set()
# 
# for idx, row in gdf_qena_speed.iterrows():
#     geom = row.geometry
# 
#     # لو الشكل مضلع أو أكثر من مضلع، نحسب مركزه
#     if geom.geom_type != "Point":
#         geom = geom.centroid
# 
#     # نحول الإحداثيات لخلية H3
#     hex_id = h3.latlng_to_cell(geom.y, geom.x, 7)
# 
#     speed_hexes.add(hex_id)
# 
# # وبعدين نستخدمه هنا
# dead_hexes = all_qina_hexes - speed_hexes
# 
# 
# speed_hexes.add(hex_id)
# 
# 
# dead_hexes = all_qina_hexes - speed_hexes
# 
# dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
# gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")
# 
# # ================================
# # 4️⃣ إنشاء الخريطة
# # ================================
# 
# st.title("🌍 Foresentra")
# 
# 
# import streamlit as st
# import numpy as np
# from streamlit_folium import st_folium
# 
# st.set_page_config(page_title="Qina Dashboard", layout="wide")
# 
# # ----- العنوان -----
# st.markdown("<h1 style='text-align:center; color:#2c3e50;'>📊 Qina Internet Coverage Dashboard</h1>", unsafe_allow_html=True)
# st.write("")
# 
# # ----- البيانات -----
# dead_zones = 0
# complaints = int(np.int64(27))
# high_demand = 304
# 
# # ----- حساب الإيرادات التقريبية -----
# # نفترض مثلاً أن كل منطقة High Demand ممكن تحقق 7,500 جنيه شهريًا
# revenue_per_area = 7500
# total_revenue = high_demand * revenue_per_area
# 
# # ----- تصميم الكروت -----
# col1, col2, col3, col4 = st.columns(4)
# 
# with col1:
#     st.markdown(
#         f"""
#         <div style='background-color:#ffe6e6; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#c0392b;'>🕳️ Dead Zones</h3>
#             <h1 style='color:#c0392b;'>{dead_zones}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col2:
#     st.markdown(
#         f"""
#         <div style='background-color:#e8f4fd; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#2980b9;'>📢 Complaints</h3>
#             <h1 style='color:#2980b9;'>{complaints}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col3:
#     st.markdown(
#         f"""
#         <div style='background-color:#eafbea; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#27ae60;'>📈 High Demand</h3>
#             <h1 style='color:#27ae60;'>{high_demand}</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# with col4:
#     st.markdown(
#         f"""
#         <div style='background-color:#fff9e6; border-radius:15px; padding:20px; text-align:center; box-shadow:2px 2px 8px rgba(0,0,0,0.1);'>
#             <h3 style='color:#f39c12;'>💰 Total Revenue</h3>
#             <h1 style='color:#f39c12;'>{total_revenue:,.0f} EGP</h1>
#         </div>
#         """,
#         unsafe_allow_html=True
#     )
# 
# # ----- فاصل -----
# st.write("")
# st.markdown("---")
# st.write("")
# 
# # ----- الخريطة (اختياري) -----
# # st_folium(map_qina, width=900, height=550)
# 
# 
# 
# 
# #-------------------------------------------
# map_center = [26.2, 32.7]
# m = folium.Map(location=map_center, zoom_start=8)
# 
# # حدود محافظة قنا
# folium.GeoJson(Qina.geometry).add_to(m)
# 
# # النقاط حسب السرعة
# for _, row in gdf_qena_speed.iterrows():
#     folium.CircleMarker(
#         location=[row.geometry.centroid.y, row.geometry.centroid.x],
#         radius=4,
#         color=color(row["avg_d_kbps"]),
#         fill=True,
#         fill_opacity=0.7
#     ).add_to(m)
# 
# # HeatMap
# heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
# HeatMap(heat_data, radius=15).add_to(m)
# 
# # Dead Zones باللون الرمادي
# folium.GeoJson(
#     gdf_dead_zones.geometry,
#     style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
# ).add_to(m)
# 
# # ================================
# # 5️⃣ إضافة بيانات السكان
# # ================================
# 
# pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
# raster = rasterio.open(pop_path)
# array = raster.read(1)
# array[array <= 0] = np.nan
# 
# with rasterio.open(pop_path) as src:
#     out_image, out_transform = mask(src, Qina.geometry, crop=True)
#     array = out_image[0]
# array[array <= 0] = np.nan
# 
# rows, cols = np.where(array > 500)
# coords = [rasterio.open(pop_path).xy(r, c) for r, c in zip(rows, cols)]
# 
# for lon, lat in coords[::200]:  # تخفيف النقاط
#     folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
# 
# # عرض الخريطة
# folium_static(m)



from pyngrok import ngrok

# Set the ngrok authtoken (replace with your actual authtoken)
os.system("ngrok authtoken 33ptHpCNcjxpzgUriZemxYK2VUU_2XvVP1dH4xyLgNeP69stV")

public_url = ngrok.connect(8501)
print("افتحي التطبيق من هنا:", public_url)

print(gdf_qena_speed.columns)



os.system("streamlit run app.py --server.port 8501")



import folium
from folium.plugins import HeatMap
import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon
import numpy as np
import rasterio
from rasterio.mask import mask


# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)


        try:
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")




# مركز قنا
map_center = [26.2, 32.7]
m = folium.Map(location=map_center, zoom_start=8)

# 1️⃣ إضافة المحافظه (حدود قنا)
folium.GeoJson(Qina.geometry).add_to(m)

# 2️⃣ النقاط الملونة حسب السرعة
def color(speed):
    if speed < 2000:  # أقل من 2 Mbps
        return "red"
    elif speed < 8000:  # بين 2 و 8 Mbps
        return "orange"
    else:
        return "green"

for _, row in gdf_qena_speed.iterrows():
    folium.CircleMarker(
        location=[row.geometry.y, row.geometry.x],
        radius=4,
        color=color(row["avg_d_kbps"]),
        fill=True,
        fill_opacity=0.7
    ).add_to(m)

# 3️⃣ إضافة HeatMap علشان نشوف التوزيع
heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
HeatMap(heat_data, radius=15).add_to(m)

# 4️⃣ الـ Dead Zones (عرض الـ dead zones باللون الرمادي)
# Use the gdf_dead_zones created in the previous step
folium.GeoJson(
    gdf_dead_zones.geometry,
    style_function=lambda x: {'fillColor': 'gray', 'color': 'gray', 'weight': 1, 'fillOpacity': 0.3}
).add_to(m)



# نقرأ ملف السكان الجديد
pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"
raster = rasterio.open(pop_path)
array = raster.read(1)
array[array <= 0] = np.nan

from rasterio.mask import mask

with rasterio.open(pop_path) as src:
    out_image, out_transform = mask(src, Qina.geometry, crop=True)
    array = out_image[0]

array[array <= 0] = np.nan


# نجيب الأماكن اللي فيها تكدس سكاني عالي
rows, cols = np.where(array > 500)  # أكتر من 500 شخص/كم²
coords = [raster.xy(r, c) for r, c in zip(rows, cols)]

# نضيف النقاط على الخريطة
for lon, lat in coords[::200]:  # نخفف النقاط شوي
    folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)
m



import folium
from folium.plugins import HeatMap
import h3
import geopandas as gpd
from shapely.geometry import Polygon
import numpy as np
import rasterio
from rasterio.mask import mask

# --------------------------
# 🧩 دالة تجيب خلايا H3 داخل حدود معينة (Polygon أو MultiPolygon)
# --------------------------
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry is None:
        return all_hexes

    # في حالة polygon أو multipolygon
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = list(geometry.geoms)
    else:
        return all_hexes

    for poly in polygons:
        geojson = poly.__geo_interface__
        try:
            # نجهز الشكل بصيغة lat, lon
            h3_poly = []
            outer = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
            h3_poly.append(outer)
            for inner_ring in geojson['coordinates'][1:]:
                h3_poly.append([(coord[1], coord[0]) for coord in inner_ring])

            # توليد خلايا H3
            hexes = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(hexes)
        except Exception as e:
            print("Error in polygon:", e)
            continue

    return all_hexes

# --------------------------
# 🗺️ توليد خلايا قنا والـ Dead Zones
# --------------------------
res = 6 # دقة H3
Qina_poly = Qina.geometry.iloc[0]  # حدود قنا
all_qina_hexes = get_hexes_in_geometry(Qina_poly, res)

# خلايا فيها بيانات سرعة
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, res)
    speed_hexes.add(hex_id)

# خلايا مافيهاش بيانات (dead zones)
dead_hexes = all_qina_hexes - speed_hexes
print("عدد خلايا dead zones:", len(dead_hexes))

# تحويل الـ dead zones إلى مضلعات
dead_zone_polygons = []
for hex_id in dead_hexes:
    boundary = h3.cell_to_boundary(hex_id)
    poly = Polygon([(lng, lat) for lat, lng in boundary])
    dead_zone_polygons.append(poly)

# إنشاء GeoDataFrame
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")
print("عدد البوليجونات في gdf_dead_zones:", len(gdf_dead_zones))

# --------------------------
# 🗺️ رسم الخريطة
# --------------------------
map_center = [26.2, 32.7]
m = folium.Map(location=map_center, zoom_start=8)

# 1️⃣ حدود قنا
folium.GeoJson(Qina.geometry, name="Qina boundary").add_to(m)

# 2️⃣ Dead Zones بالرمادي
if len(gdf_dead_zones) > 0:
    folium.GeoJson(
        gdf_dead_zones,
        style_function=lambda x: {
            'fillColor': 'gray',
            'color': 'gray',
            'weight': 0.5,
            'fillOpacity': 0.7
        },
        name="Dead Zones"
    ).add_to(m)

# 3️⃣ النقاط حسب السرعة
def color(speed):
    if speed < 2000:
        return "red"
    elif speed < 8000:
        return "orange"
    else:
        return "green"

for _, row in gdf_qena_speed.iterrows():
    folium.CircleMarker(
        location=[row.geometry.y, row.geometry.x],
        radius=4,
        color=color(row["avg_d_kbps"]),
        fill=True,
        fill_opacity=0.7
    ).add_to(m)

# 4️⃣ HeatMap
heat_data = [[row.geometry.y, row.geometry.x, row["avg_d_kbps"]] for _, row in gdf_qena_speed.iterrows()]
HeatMap(heat_data, radius=15).add_to(m)

# --------------------------
# 👥 توزيع السكان
# --------------------------
pop_path = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"

with rasterio.open(pop_path) as src:
    out_image, out_transform = mask(src, Qina.geometry, crop=True)
    array = out_image[0]

array[array <= 0] = np.nan

rows, cols = np.where(array > 500)
coords = [rasterio.open(pop_path).xy(r, c) for r, c in zip(rows, cols)]

for lon, lat in coords[::200]:
    folium.CircleMarker(location=[lat, lon], radius=2, color="black", fill=True).add_to(m)

m

print("عدد خلايا قنا:", len(all_qina_hexes))

print("عدد خلايا فيها سرعات:", len(speed_hexes))

print("عدد خلايا dead zones:", len(dead_hexes))

os.system("pip install rasterio")

import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon

# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)

        # Debugging print statements
        print("Processing polygon:")
        print(f"  Geometry type: {poly.geom_type}")
        print(f"  H3 polygon input format (first few points): {h3_poly[0][:5]}") # Print first 5 points of outer loop

        try:
            # Use h3.polygon_to_cells instead of h3.polygon_to_cells_geojson
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
            print(f"  Successfully generated {len(grid)} hexes for this polygon.")
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    # Use h3.latlng_to_cell instead of h3.geo_to_h3
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")

print("\nNumber of dead zone hexes:", len(dead_hexes))
print("\nGeoDataFrame of dead zones created:")
display(gdf_dead_zones.head())

np.nanmax(array)

import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon

# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)

        # Debugging print statements
        print("Processing polygon:")
        print(f"  Geometry type: {poly.geom_type}")
        print(f"  H3 polygon input format (first few points): {h3_poly[0][:5]}") # Print first 5 points of outer loop

        try:
            # Use h3.polygon_to_cells instead of h3.polygon_to_cells_geojson
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
            print(f"  Successfully generated {len(grid)} hexes for this polygon.")
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    # Use h3.latlng_to_cell instead of h3.geo_to_h3
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")

print("\nNumber of dead zone hexes:", len(dead_hexes))
print("\nGeoDataFrame of dead zones created:")
display(gdf_dead_zones.head())

# قراءة حدود مصر (assuming egypt_boundaries is already loaded)
# If egypt_boundaries is not loaded, add the code to load it here.
# import geopandas as gpd
# boundaries_path = "/content/gadm41_EGY_1.json"
# egypt_boundaries = gpd.read_file(boundaries_path)

# اختيار حدود محافظة قنا من GeoDataFrame
# تأكدي من أن اسم عمود اسم المحافظة هو 'NAME_1' وأن اسم قنا مكتوب بنفس الطريقة الموجودة في البيانات
Qina = egypt_boundaries[egypt_boundaries['NAME_1'] == 'Qina']

print("تم اختيار حدود قنا:")
display(Qina)

import h3
import geopandas as gpd
from shapely.geometry import Polygon, MultiPolygon

# Function to get H3 hexes within a polygon or multipolygon
def get_hexes_in_geometry(geometry, res):
    all_hexes = set()
    if geometry.geom_type == 'Polygon':
        polygons = [geometry]
    elif geometry.geom_type == 'MultiPolygon':
        polygons = geometry.geoms
    else:
        return all_hexes # Handle other geometry types if necessary

    for poly in polygons:
        geojson = poly.__geo_interface__
        h3_poly = []
        # Exterior ring
        outer_loop = [(coord[1], coord[0]) for coord in geojson['coordinates'][0]]
        h3_poly.append(outer_loop)
        # Inner rings (holes)
        inner_loops = [[(coord[1], coord[0]) for coord in inner_ring] for inner_ring in geojson['coordinates'][1:]]
        h3_poly.extend(inner_loops)

        # Debugging print statements
        print("Processing polygon:")
        print(f"  Geometry type: {poly.geom_type}")
        print(f"  H3 polygon input format (first few points): {h3_poly[0][:5]}") # Print first 5 points of outer loop

        try:
            grid = h3.polygon_to_cells(h3_poly, res=res)
            all_hexes.update(grid)
            print(f"  Successfully generated {len(grid)} hexes for this polygon.")
        except ValueError as e:
            print(f"  Error generating hexes for this polygon: {e}")
            print(f"  Problematic h3_poly structure: {h3_poly}")


    return all_hexes

# Get H3 hexes for Qina at resolution 7
all_qina_hexes = get_hexes_in_geometry(Qina.geometry.iloc[0], res=7) # Assuming Qina is a single row GeoDataFrame

# Get H3 hexes for the points with speed data
speed_hexes = set()
for _, row in gdf_qena_speed.iterrows():
    hex_id = h3.latlng_to_cell(row.geometry.y, row.geometry.x, 7)
    speed_hexes.add(hex_id)

# Calculate dead zones (hexes in Qina without speed data)
dead_hexes = all_qina_hexes - speed_hexes

# Convert dead zones to GeoDataFrame
dead_zone_polygons = [Polygon(h3.h3_to_geo_boundary(hex_id, geo_json=True)) for hex_id in dead_hexes]
gdf_dead_zones = gpd.GeoDataFrame({'geometry': dead_zone_polygons}, crs="EPSG:4326")

print("\nNumber of dead zone hexes:", len(dead_hexes))
print("\nGeoDataFrame of dead zones created:")
display(gdf_dead_zones.head())

# تحليل الجداول وتجميع بيانات السكان لمراكز قنا
population_data = []

for i, table in enumerate(tables):
    print(f"\n--- تحليل الجدول رقم {i+1} ---")
    # محاولة تحديد الأعمدة ذات الصلة بناءً على رؤوس الجداول المعروضة سابقًا
    # قد تحتاج هذه الأسماء إلى تعديل بناءً على رأس الجدول الفعلي
    population_col = None
    type_col = None
    district_col = None

    # محاولة تحديد الأعمدة بناءً على الكلمات المفتاحية في الرأس
    for col in table.columns:
        if "عدد السكان" in str(col) or "Unnamed: 0" in str(col): # Consider Unnamed: 0 as potential population column
            population_col = col
        if "النوع" in str(col) or "Unnamed: 1" in str(col): # Consider Unnamed: 1 as potential type column
            type_col = col
        # Use broader keywords for district column
        if any(keyword in str(col) for keyword in ["القسم", "المركز", "مركز", "مدينة"]):
             district_col = col
        # If no specific district column is found, check Unnamed columns for potential district names
        if district_col is None:
            for col in table.columns:
                 if "Unnamed" in str(col) and col != population_col and col != type_col:
                      # Check if this Unnamed column contains potential district names
                      if table[col].astype(str).str.contains("قنا|الوقف|فرشوط|أبو طشت|دشنا|الوقف|قفط|نقادة|القرنة|أرمنت|الوقف|إسنا|الواحات الخارجة|الداخلة|الفرافرة|باريس|بلاط|مدينة قنا الجديدة|إجمالى المحافظة", na=False).any():
                           district_col = col
                           break # Found a potential district column


    if population_col is not None and (type_col is not None or district_col is not None):
        print(f"  تم تحديد الأعمدة: السكان ('{population_col}'), النوع ('{type_col}'), القسم/المركز ('{district_col}')")
        # تصفية الصفوف التي تحتوي على "جملة" في عمود النوع (إذا وجد) أو التي تحتوي على اسم مركز في عمود القسم/المركز
        if type_col is not None and type_col in table.columns:
             # البحث عن الصفوف التي تحتوي على كلمة "جملة"
            total_rows = table[table[type_col].astype(str).str.contains("جملة", na=False)]
            print(f"  تم العثور على {len(total_rows)} صفوف 'جملة'.")
            # استخلاص اسم المركز وعدد السكان من صفوف "جملة"
            for index, row in total_rows.iterrows():
                  center_name = None
                  population_value = None

                  # Try to get center name from potential district column
                  if district_col is not None and district_col in row and pd.notna(row[district_col]):
                       center_name_candidate = str(row[district_col]).strip()
                       if any(keyword in center_name_candidate for keyword in ["مركز", "مدينة", "قسم", "إجمالى المحافظة", "جملة"]): # Include "جملة" as some tables have it in the district column
                            center_name = center_name_candidate

                  # If center name not found in district column, look in other columns in the same row
                  if not center_name:
                       for col in table.columns:
                            if col != population_col and col != type_col and pd.notna(row[col]):
                                 col_value = str(row[col]).strip()
                                 if any(keyword in col_value for keyword in ["مركز", "مدينة", "قسم", "إجمالى المحافظة", "جملة"]):
                                      center_name = col_value
                                      break # Stop at the first potential center name

                  # Extract population value from the identified population column
                  if population_col in row and pd.notna(row[population_col]):
                       try:
                            population_value = float(str(row[population_col]).replace(',', '').strip())
                       except ValueError:
                            population_value = None # Value is not numeric

                  # If a valid center name and population value are found, add them
                  if center_name and population_value is not None:
                       # Avoid adding "إجمالى المحافظة" rows unless specifically needed later
                       if "إجمالى المحافظة" not in center_name:
                           population_data.append({"المركز": center_name.replace("جملة", "").strip(), "عدد السكان الإجمالي": population_value}) # Clean up "جملة" from name
                           print(f"    استخلاص: المركز '{center_name.replace('جملة', '').strip()}', السكان '{population_value}'")
                       else:
                           print(f"    تم تخطي صف إجمالى المحافظة: المركز '{center_name}', السكان '{population_value}'")

        elif district_col is not None and district_col in table.columns and population_col is not None and population_col in table.columns:
             # If no type column, try extracting directly based on district column containing keywords
             print("  لا يوجد عمود نوع، نحاول استخلاص البيانات مباشرة من أعمدة القسم/المركز والسكان.")
             for index, row in table.iterrows():
                  center_name = None
                  population_value = None

                  if pd.notna(row[district_col]):
                       center_name_candidate = str(row[district_col]).strip()
                       if any(keyword in center_name_candidate for keyword in ["مركز", "مدينة", "قسم", "إجمالى المحافظة", "جملة"]):
                            center_name = center_name_candidate

                            if population_col in row and pd.notna(row[population_col]):
                                 try:
                                      population_value = float(str(row[population_col]).replace(',', '').strip())
                                 except ValueError:
                                      population_value = None

                            if center_name and population_value is not None and "إجمالى المحافظة" not in center_name:
                                 population_data.append({"المركز": center_name.replace("جملة", "").strip(), "عدد السكان الإجمالي": population_value})
                                 print(f"    استخلاص: المركز '{center_name.replace('جملة', '').strip()}', السكان '{population_value}'")
                            elif "إجمالى المحافظة" in center_name:
                                print(f"    تم تخطي صف إجمالى المحافظة: المركز '{center_name}', السكان '{population_value}'")


    else:
        print("  لم يتم تحديد الأعمدة المطلوبة (عمود السكان على الأقل وعمود النوع أو القسم/المركز) في هذا الجدول.")


# تحويل البيانات المجمعة إلى DataFrame
population_df = pd.DataFrame(population_data)

# تنظيف إضافي (إزالة الصفوف المكررة)
if not population_df.empty:
    population_df = population_df.drop_duplicates(subset=["المركز"])
    # تأكد من إزالة أي صفوف تحتوي على إجمالي المحافظة التي قد تكون تسللت
    population_df = population_df[~population_df["المركز"].astype(str).str.contains("إجمالى المحافظة", na=False)]


print("\nبيانات السكان المجمعة لمراكز قنا:")
if not population_df.empty:
    display(population_df)
else:
    print("لم يتم تجميع أي بيانات سكانية.")


# الخطوة التالية: الربط بالبيانات الجغرافية لمراكز قنا

# عرض رؤوس الجداول الخمسة المستخلصة
print(f"تم استخلاص {len(tables)} جدول من الصفحات 90-94.")

for i, table in enumerate(tables):
    print(f"\n--- الجدول رقم {i+1} (من الصفحات 90-94) ---")
    display(table.head())
    # يمكنكِ أيضًا عرض الجدول بالكامل إذا كان صغيرًا:
    # display(table)

# فلترة الجداول للعثور على بيانات قنا
qena_table = None
keywords = ["قنا", "Qina", "Kena", "Quena"] # كلمات مفتاحية للبحث عن جدول قنا

for i, table in enumerate(tables):
    # تحويل الجدول إلى سلسلة نصية للبحث فيه
    table_string = table.to_string()
    # البحث عن الكلمات المفتاحية في محتوى الجدول
    if any(keyword in table_string for keyword in keywords):
        print(f"تم العثور على جدول يحتمل أنه يحتوي على بيانات قنا (الجدول رقم {i+1}).")
        qena_table = table
        # يمكنك عرض الجدول هنا للتأكد
        # display(qena_table.head())
        # يمكننا التوقف عند العثور على أول جدول مطابق أو الاستمرار للبحث عن جداول أخرى إذا لزم الأمر
        # break # أزل علامة التعليق هنا للتوقف بعد العثور على أول جدول
    else:
      print(f"الجدول رقم {i+1} لا يحتوي على الكلمات المفتاحية.")


if qena_table is not None:
    print("\nتم تحديد جدول بيانات قنا.")
    display(qena_table.head())
else:
    print("\nلم يتم العثور على جدول يحتوي على بيانات قنا باستخدام الكلمات المفتاحية.")

# في الخطوة التالية، إذا تم العثور على الجدول، سنقوم بتنظيم بياناته واستخلاص أعداد السكان لكل مركز.

"""**ملاحظة هامة:** استخلاص البيانات من ملفات PDF قد يكون صعبًا ويعتمد على هيكل الملف وتنسيق الجداول فيه. قد تحتاج هذه الخطوة إلى تعديلات بناءً على بنية ملف الـ PDF الخاص بك."""

os.system("pip install tabula-py --quiet")

import tabula

# تحديد مسار ملف الـ PDF الذي قمتِ بتحميله
pdf_path = '/content/202331512347عدد السكان على مستوى المراكز والاقسام فى 1ـ 1ـ 2023.pdf'

# محاولة قراءة الجداول من ملف الـ PDF
# قد تحتاج إلى تحديد أرقام الصفحات التي تحتوي على بيانات السكان
# يمكنكِ محاولة قراءة جميع الصفحات في البداية
try:
    # تحديد الصفحات من 90 إلى 94
    tables = tabula.read_pdf(pdf_path, pages='90-94', multiple_tables=True)
    print(f"تم العثور على {len(tables)} جدول في الصفحات 90-94 من ملف PDF.")
    # عرض أول جدول للمعاينة
    if tables:
        display(tables[0].head())
    else:
        print("لم يتم العثور على أي جداول في الصفحات المحددة.")

except Exception as e:
    print(f"حدث خطأ أثناء قراءة ملف PDF: {e}")

# في الخطوة التالية، سنقوم بتحليل الجداول المستخلصة وتحديد جدول بيانات قنا.

!wget https://hub.worldpop.org/geodata/10.5258/SOTON/WP00803/egy_ppp_2025.tif

import geopandas as gpd
import rasterio
from rasterio.mask import mask
import matplotlib.pyplot as plt

# 1) افتحي حدود مصر
# gdf = gpd.read_file("gadm41_EGY_1.shp") # Already loaded as egypt_boundaries

# 2) اختاري قنا
# qena = gdf[gdf['NAME_1'] == 'Qena'] # Use egypt_boundaries and correct spelling
qena = egypt_boundaries[egypt_boundaries['NAME_1'] == 'Qina']


# 3) افتحي ملف السكان (اللي نزلتيه)
pop = rasterio.open("/content/egy_pop_2025_CN_100m_R2024B_v1.tif")  # غيري الاسم لو الملف عندك 2020 أو سنة تانية

# 4) قص ملف السكان على حدود قنا
out_image, out_transform = mask(pop, qena.geometry, crop=True)
population_array = out_image[0]

# 5) شوفي النتيجة
plt.imshow(population_array, cmap="viridis")
plt.colorbar(label="Population count")
plt.title("Population distribution in Qena")
plt.show()

# اختيار حدود محافظة قنا من GeoDataFrame
# تأكدي من أن اسم عمود اسم المحافظة هو 'NAME_1' وأن اسم قنا مكتوب بنفس الطريقة الموجودة في البيانات
qena_boundary = egypt_boundaries[egypt_boundaries['NAME_1'] == 'Qina']

print("تم اختيار حدود قنا:")
display(qena_boundary)

import geopandas as gpd

# تحديد مسار ملف الحدود
boundaries_path = "/content/gadm41_EGY_1.json"

try:
    # قراءة ملف الحدود
    egypt_boundaries = gpd.read_file(boundaries_path)

    print(f"تم قراءة الملف: {boundaries_path}")
    print("\nأول 5 صفوف من بيانات الحدود:")
    display(egypt_boundaries.head())

    print("\nأسماء الأعمدة:")
    print(egypt_boundaries.columns)

    # محاولة عرض قيم فريدة من عمود البلد (قد يختلف اسم العمود)
    if 'COUNTRY' in egypt_boundaries.columns:
        print("\nالقيم الفريدة في عمود 'COUNTRY':")
        print(egypt_boundaries['COUNTRY'].unique())
    elif 'NAME_0' in egypt_boundaries.columns:
        print("\nالقيم الفريدة في عمود 'NAME_0':")
        print(egypt_boundaries['NAME_0'].unique())
    else:
        print("\nلم يتم العثور على عمود باسم 'COUNTRY' أو 'NAME_0'.")

    print(f"\nعدد الميزات الجغرافية في الملف: {len(egypt_boundaries)}")


except Exception as e:
    print(f"حدث خطأ أثناء قراءة ملف الحدود: {e}")



import geopandas as gpd
import rasterio
from rasterio.mask import mask

# ملفاتك
pop_file = "/content/egy_pop_2025_CN_100m_R2024B_v1.tif"   # ملف السكان اللي نزلتيه
# admin_file = "/content/ne_110m_admin_0_countries.shp"  # ملف المحافظات - لا نحتاجه هنا بعد الآن

# نقرأ shapefile (already loaded as egypt_boundaries)
# gdf = gpd.read_file(admin_file)

# نختار المحافظة المطلوبة (قنا) من egypt_boundaries
governorate = egypt_boundaries[egypt_boundaries['NAME_1'] == 'Qina']

# نفتح ملف السكان
with rasterio.open(pop_file) as src:
    out_image, out_transform = mask(src, governorate.geometry, crop=True)
    out_meta = src.meta.copy()

# نحدث الميتاداتا
out_meta.update({
    "driver": "GTiff",
    "height": out_image.shape[1],
    "width": out_image.shape[2],
    "transform": out_transform
})

# نحفظ الناتج في ملف جديد
with rasterio.open("qina_population.tif", "w", **out_meta) as dest:
    dest.write(out_image)

print("تم قص ملف السكان على حدود قنا وحفظه كـ qina_population.tif")